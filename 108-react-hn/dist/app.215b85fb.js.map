{"version":3,"sources":["webpack:///app.215b85fb.js","webpack:///./src/index.js","webpack:///./src/routes.js","webpack:///./src/Item.js","webpack:///./src/services/HNService.js","webpack:///./src/services/HNServiceRest.js","webpack:///./src/stores/StoryCommentThreadStore.js","webpack:///./src/stores/CommentThreadStore.js","webpack:///./src/utils/extend.js","webpack:///./src/stores/SettingsStore.js","webpack:///./src/utils/storage.js","webpack:///./src/utils/cancellableDebounce.js","webpack:///./src/utils/pluralise.js","webpack:///./src/stores/ItemStore.js","webpack:///./src/stores/StoryStore.js","webpack:///./src/stores/UpdatesStore.js","webpack:///./src/utils/constants.js","webpack:///./src/DisplayComment.js","webpack:///./src/mixins/CommentMixin.js","webpack:///./src/Spinner.js","webpack:///./src/utils/buildClassName.js","webpack:///./src/PollOption.js","webpack:///./src/mixins/ItemMixin.js","webpack:///./src/utils/setTitle.js","webpack:///./src/App.js","webpack:///./src/Settings.js","webpack:///./src/Stories.js","webpack:///./src/mixins/PageNumberMixin.js","webpack:///./src/Paginator.js","webpack:///./src/StoryListItem.js","webpack:///./src/mixins/ListItemMixin.js","webpack:///./src/utils/pageCalc.js","webpack:///./src/Updates.js","webpack:///./src/DisplayListItem.js","webpack:///./src/Comment.js"],"names":["webpackJsonp","lVK7","module","exports","__webpack_require__","React","_require","render","Router","createHashHistory","useScroll","applyRouterMiddleware","history","routes","createElement","document","getElementById","0","eqvY","stories","route","type","limit","title","createClass","Stories","_extends","this","props","key","updates","Updates","Object","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","IndexRoute","Route","Item","App","Ask","Comments","Jobs","New","Show","Top","path","component","getComponent","location","callback","e","require","t0E4","timeUnitsAgo","value","unit","suffix","ReactFireMixin","TimeAgo","default","HNService","HNServiceRest","StoryCommentThreadStore","ItemStore","Comment","PollOption","Spinner","ItemMixin","cx","setTitle","SettingsStore","displayName","mixins","getInitialState","item","getCachedStory","Number","params","id","componentWillMount","offlineMode","itemRef","then","res","json","snapshot","replaceState","bind","bindAsObject","state","threadStore","handleCommentsChanged","cached","window","addEventListener","handleBeforeUnload","componentWillUnmount","dispose","removeEventListener","componentWillReceiveProps","nextProps","unbind","setState","componentWillUpdate","nextState","componentDidUpdate","prevProps","prevState","itemId","forceUpdate","loading","kids","prevKids","kidDiff","adjustExpectedComments","itemUpdated","payload","autoCollapse","preventDefault","collapseThreadsWithoutNewComments","markAsRead","className","Item--dead","dead","renderItemTitle","renderItemMeta","lastVisit","newCommentCount","date","formatter","tabIndex","onClick","onKeyPress","text","dangerouslySetInnerHTML","__html","parts","map","index","level","loadingSpinner","size","VIGu","fetchItem","cb","once","val","fetchItems","ids","addItem","items","push","forEach","storiesRef","api","child","userRef","updatesRef","firebase","config","databaseURL","initializeApp","version","database","ref","uaYK","fetch","endPoint","options","itemRefJSON","response","promises","Promise","all","values","method","headers","Accept","PJIF","loadState","storage","get","JSON","parse","commentCount","maxCommentId","onCommentsChanged","CommentThreadStore","startedLoading","Date","now","parents","expectedComments","itemDescendantCount","descendants","initialState","prevMaxCommentId","isFirstVisit","checkLoadCompletion","debounce","extend","create","constructor","numberOfCommentsChanged","firstLoadComplete","_storeState","set","stringify","commentAdded","comment","deleted","showDead","isNew","parent","commentDelayed","commentId","commentDeleted","commentDied","change","newCommentIds","keys","hasNewComments","l","shouldCollapse","commentIds","children","nextCommentIds","childCommentIds","apply","isCollapsed","cancel","Hwo6","getChildCounts","childCount","nodes","nextNodes","nodeChildren","newComments","siblings","splice","indexOf","toggleCollapse","7S1B","dest","src1","src2","NPdQ","STORAGE_KEY","replyLinks","showDeleted","titleFontSize","listSpacing","load","save","VKKs","defaultValue","localStorage","Y1Gy","cancellableDebounce","func","wait","immediate","timeout","args","context","timestamp","result","later","last","setTimeout","debounced","callNow","clearTimeout","HSmy","pluralise","howMany","suffixes","split","bRBh","setImmediate","fetchCommentParent","parentId","commentParentLookup","titleCache","itemCount","cacheHits","op","getItem","processCommentParent","StoryStore","UpdatesStore","cachedItem","getCachedItem","getStory","fetchCommentAncestors","startTime","timeTaken","FA3V","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","enumerable","writable","configurable","setPrototypeOf","__proto__","populateStoryList","idCache","storyList","storyLists","itemCache","parseJSON","_createClass","defineProperties","descriptor","defineProperty","protoProps","staticProps","EventEmitter","firebaseRef","_EventEmitter","_this","getPrototypeOf","onStorage","onStoriesUpdated","emit","getState","on","off","loadSession","sessionStorage","saveSession","setItem","fsMb","sortByTimeDesc","a","b","time","cacheObjToSortedArray","obj","arr","sort","populateUpdates","comments","processCacheObj","updatesCache","cacheObj","UPDATES_CACHE_SIZE","Math","max","handleUpdateItems","updateItemTypes","job","poll","story","start","stop","getUpdates","getComment","removeListener","FN8c","ITEMS_PER_PAGE","SITE_TITLE","VThE","CommentMixin","DisplayComment","fetchAncestors","Comment--dead","renderCommentMeta","link","renderCommentText","replyLink","bFfS","Link","isMounted","renderCommentLoading","delayed","renderCommentDeleted","href","renderError","renderCollapseControl","collapsed","collapsible","childCounts","to","by","OieW","getDefaultProps","spacing","bounceSize","bounceStyle","height","width","marginRight","style","H9Jo","buildClassName","staticClassName","conditionalClassNames","classNames","classNameKeys","join","j+W0","pollopt","score","sZWe","urlParse","parseHost","url","hostname","slice","shift","extraContent","itemDate","hasURL","fontSize","SIDF","pnOm","Settings","showSettings","showChildren","prebootHTML","componentDidMount","toggleSettings","src","alt","activeClassName","sFNP","refs","container","focus","onChange","el","name","checked","stopPropagation","htmlFor","min","step","dApQ","PageNumberMixin","Paginator","StoryListItem","pageCalc","store","addListener","handleUpdate","update","page","getPageNumber","dummyItems","startIndex","endIndex","marginBottom","pageNum","hasNext","renderItems","rendered","eigB","query","test","SE0F","_onClick","scrollTo","pathname","ITt7","ListItemMixin","initLiveItem","threadState","updateThreadState","renderListItem","J1hE","getNewCommentCount","ListItem--dead","gah7","pageSize","numItems","S+0w","filterDead","filterUpdates","filter","DisplayListItem","handleUpdates","USDx","4fZb","bindFirebaseRef","clearDelayTimeout","handleFirebaseRefCancelled","Comment--collapsed","Comment--new"],"mappings":"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","file":"app.215b85fb.js","sourcesContent":["webpackJsonp([0,5,6],{\n\n/***/ \"lVK7\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(\"AYvJ\");\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\tvar _require = __webpack_require__(\"E2wb\"),\n\t    render = _require.render;\n\t\n\tvar Router = __webpack_require__(\"Zi33\");\n\tvar createHashHistory = __webpack_require__(\"SQnC\");\n\tvar useScroll = __webpack_require__(\"6REo\");\n\tvar applyRouterMiddleware = __webpack_require__(\"Ffs3\");\n\tvar history = createHashHistory();\n\t\n\tvar routes = __webpack_require__(\"eqvY\");\n\t\n\trender(React.createElement(Router, { history: history, render: applyRouterMiddleware(useScroll()), routes: routes }), document.getElementById('app'));\n\n/***/ },\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(\"zGZA\");\n\tmodule.exports = __webpack_require__(\"lVK7\");\n\n\n/***/ },\n\n/***/ \"eqvY\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar IndexRoute = __webpack_require__(\"P44o\");\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar Route = __webpack_require__(\"gY3N\");\n\tvar Item = __webpack_require__(\"t0E4\");\n\t// Polyfill require.ensure\n\tif (false) require.ensure = function (d, c) {\n\t  c(require);\n\t};\n\t\n\tvar App = __webpack_require__(\"pnOm\");\n\tvar Stories = __webpack_require__(\"dApQ\");\n\tvar Updates = __webpack_require__(\"S+0w\");\n\t\n\tfunction stories(route, type, limit, title) {\n\t  return React.createClass({\n\t    render: function render() {\n\t      return React.createElement(Stories, _extends({}, this.props, { key: route, route: route, type: type, limit: limit, title: title }));\n\t    }\n\t  });\n\t}\n\t\n\tfunction updates(type) {\n\t  return React.createClass({\n\t    render: function render() {\n\t      return React.createElement(Updates, _extends({}, this.props, { key: type, type: type }));\n\t    }\n\t  });\n\t}\n\t\n\tvar Ask = stories('ask', 'askstories', 200, 'Ask');\n\tvar Comments = updates('comments');\n\tvar Jobs = stories('jobs', 'jobstories', 200, 'Jobs');\n\tvar New = stories('newest', 'newstories', 500, 'New Links');\n\tvar Show = stories('show', 'showstories', 200, 'Show');\n\tvar Top = stories('news', 'topstories', 500);\n\t\n\tmodule.exports = React.createElement(\n\t  Route,\n\t  { path: '/', component: App },\n\t  React.createElement(IndexRoute, { component: Top }),\n\t  React.createElement(Route, { path: 'news', component: Top }),\n\t  React.createElement(Route, { path: 'newest', component: New }),\n\t  React.createElement(Route, { path: 'show', component: Show }),\n\t  React.createElement(Route, { path: 'ask', component: Ask }),\n\t  React.createElement(Route, { path: 'jobs', component: Jobs }),\n\t  React.createElement(Route, { path: 'item/:id', component: Item }),\n\t  React.createElement(Route, { path: 'job/:id', component: Item }),\n\t  React.createElement(Route, { path: 'poll/:id', component: Item }),\n\t  React.createElement(Route, { path: 'story/:id', component: Item }),\n\t  React.createElement(Route, {\n\t    path: 'comment/:id',\n\t    getComponent: function getComponent(location, callback) {\n\t      __webpack_require__.e/* nsure */(1, function (require) {\n\t        callback(null, __webpack_require__(\"AcQZ\"));\n\t      });\n\t    }\n\t  }),\n\t  React.createElement(Route, { path: 'newcomments', component: Comments }),\n\t  React.createElement(Route, {\n\t    path: 'user/:id',\n\t    getComponent: function getComponent(location, callback) {\n\t      __webpack_require__.e/* nsure */(2, function (require) {\n\t        callback(null, __webpack_require__(\"4B7v\"));\n\t      });\n\t    }\n\t  }),\n\t  React.createElement(Route, {\n\t    path: '*',\n\t    getComponent: function getComponent(location, callback) {\n\t      __webpack_require__.e/* nsure */(3, function (require) {\n\t        callback(null, __webpack_require__(\"O9aJ\"));\n\t      });\n\t    }\n\t  })\n\t);\n\n/***/ },\n\n/***/ \"t0E4\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar ReactFireMixin = __webpack_require__(\"ZZqC\");\n\tvar TimeAgo = __webpack_require__(\"z3IR\").default;\n\t\n\tvar HNService = __webpack_require__(\"VIGu\");\n\tvar HNServiceRest = __webpack_require__(\"uaYK\");\n\tvar StoryCommentThreadStore = __webpack_require__(\"PJIF\");\n\tvar ItemStore = __webpack_require__(\"bRBh\");\n\t\n\tvar Comment = __webpack_require__(\"4fZb\");\n\tvar PollOption = __webpack_require__(\"j+W0\");\n\tvar Spinner = __webpack_require__(\"OieW\");\n\tvar ItemMixin = __webpack_require__(\"sZWe\");\n\t\n\tvar cx = __webpack_require__(\"H9Jo\");\n\tvar setTitle = __webpack_require__(\"SIDF\");\n\t\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tfunction timeUnitsAgo(value, unit, suffix) {\n\t  if (value === 1) {\n\t    return unit;\n\t  }\n\t  return value + ' ' + unit + 's';\n\t}\n\t\n\tvar Item = React.createClass({\n\t  displayName: 'Item',\n\t\n\t  mixins: [ItemMixin, ReactFireMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      item: ItemStore.getCachedStory(Number(this.props.params.id)) || {}\n\t    };\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    if (SettingsStore.offlineMode) {\n\t      HNServiceRest.itemRef(this.props.params.id).then(function (res) {\n\t        return res.json();\n\t      }).then(function (snapshot) {\n\t        this.replaceState({ item: snapshot });\n\t      }.bind(this));\n\t    } else {\n\t      this.bindAsObject(HNService.itemRef(this.props.params.id), 'item');\n\t    }\n\t\n\t    if (this.state.item.id) {\n\t      this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, { cached: true });\n\t      setTitle(this.state.item.title);\n\t    }\n\t    window.addEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    if (this.threadStore) {\n\t      this.threadStore.dispose();\n\t    }\n\t    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.params.id !== nextProps.params.id) {\n\t      // Tear it down...\n\t      this.threadStore.dispose();\n\t      this.threadStore = null;\n\t      this.unbind('item');\n\t      // ...and set it up again\n\t      var item = ItemStore.getCachedStory(Number(nextProps.params.id));\n\t      if (item) {\n\t        this.threadStore = new StoryCommentThreadStore(item, this.handleCommentsChanged, { cached: true });\n\t        setTitle(item.title);\n\t      }\n\t\n\t      if (SettingsStore.offlineMode) {\n\t        HNServiceRest.itemRef(nextProps.params.id).then(function (res) {\n\t          return res.json();\n\t        }).then(function (snapshot) {\n\t          this.replaceState({ item: snapshot });\n\t        }.bind(this));\n\t      } else {\n\t        this.bindAsObject(HNService.itemRef(nextProps.params.id), 'item');\n\t        this.setState({ item: item || {} });\n\t      }\n\t    }\n\t  },\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    // Update the title when the item has loaded.\n\t    if (!this.state.item.id && nextState.item.id) {\n\t      setTitle(nextState.item.title);\n\t    }\n\t  },\n\t  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t    // If the state item id changed, an initial or new item must have loaded\n\t    if (prevState.item.id !== this.state.item.id) {\n\t      if (!this.threadStore || this.threadStore.itemId !== this.state.item.id) {\n\t        this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, { cached: false });\n\t        setTitle(this.state.item.title);\n\t        this.forceUpdate();\n\t      }\n\t    } else if (prevState.item !== this.state.item) {\n\t      // If the item has been updated from Firebase and the initial set\n\t      // of comments is still loading, the number of expected comments might\n\t      // need to be adjusted.\n\t      // This triggers a check for thread load completion, completing it\n\t      // immediately if a cached item had 0 kids and the latest version from\n\t      // Firebase also has 0 kids.\n\t      if (this.threadStore.loading) {\n\t        var kids = this.state.item.kids ? this.state.item.kids.length : 0;\n\t        var prevKids = prevState.item.kids ? prevState.item.kids.length : 0;\n\t        var kidDiff = kids - prevKids;\n\t        if (kidDiff !== 0) {\n\t          this.threadStore.adjustExpectedComments(kidDiff);\n\t        }\n\t      }\n\t      this.threadStore.itemUpdated(this.state.item);\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Ensure the last visit time and comment details get stored for this item if\r\n\t   * the user refreshes or otherwise navigates off the page.\r\n\t   */\n\t  handleBeforeUnload: function handleBeforeUnload() {\n\t    if (this.threadStore) {\n\t      this.threadStore.dispose();\n\t    }\n\t  },\n\t  handleCommentsChanged: function handleCommentsChanged(payload) {\n\t    this.forceUpdate();\n\t  },\n\t  autoCollapse: function autoCollapse(e) {\n\t    e.preventDefault();\n\t    this.threadStore.collapseThreadsWithoutNewComments();\n\t  },\n\t  markAsRead: function markAsRead(e) {\n\t    e.preventDefault();\n\t    this.threadStore.markAsRead();\n\t    this.forceUpdate();\n\t  },\n\t  render: function render() {\n\t    var state = this.state;\n\t    var item = state.item;\n\t    var threadStore = this.threadStore;\n\t    if (!item.id || !threadStore) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Item Item--loading' },\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: cx('Item', { 'Item--dead': item.dead }) },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Item__content' },\n\t        this.renderItemTitle(item),\n\t        this.renderItemMeta(item, threadStore.lastVisit !== null && threadStore.newCommentCount > 0 && React.createElement(\n\t          'span',\n\t          null,\n\t          ' ',\n\t          '(',\n\t          React.createElement(\n\t            'em',\n\t            null,\n\t            threadStore.newCommentCount,\n\t            ' new'\n\t          ),\n\t          ' in the last ',\n\t          React.createElement(TimeAgo, { date: threadStore.lastVisit, formatter: timeUnitsAgo }),\n\t          ') | ',\n\t          React.createElement(\n\t            'span',\n\t            { className: 'control', tabIndex: '0', onClick: this.autoCollapse, onKeyPress: this.autoCollapse, title: 'Collapse threads without new comments' },\n\t            'auto collapse'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            'span',\n\t            { className: 'control', tabIndex: '0', onClick: this.markAsRead, onKeyPress: this.markAsRead },\n\t            'mark as read'\n\t          )\n\t        )),\n\t        item.text && React.createElement(\n\t          'div',\n\t          { className: 'Item__text' },\n\t          React.createElement('div', { dangerouslySetInnerHTML: { __html: item.text } })\n\t        ),\n\t        item.type === 'poll' && React.createElement(\n\t          'div',\n\t          { className: 'Item__poll' },\n\t          item.parts.map(function (id) {\n\t            return React.createElement(PollOption, { key: id, id: id });\n\t          })\n\t        )\n\t      ),\n\t      item.kids && React.createElement(\n\t        'div',\n\t        { className: 'Item__kids' },\n\t        item.kids.map(function (id, index) {\n\t          return React.createElement(Comment, { key: id, id: id, level: 0,\n\t            loadingSpinner: index === 0,\n\t            threadStore: threadStore\n\t          });\n\t        })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Item;\n\n/***/ },\n\n/***/ \"VIGu\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar firebase = __webpack_require__(\"LT+6\");\n\t__webpack_require__(\"hFFK\");\n\t\n\tvar config = {\n\t  databaseURL: 'https://hacker-news.firebaseio.com'\n\t};\n\tfirebase.initializeApp(config);\n\tvar version = '/v0';\n\tvar api = firebase.database().ref(version);\n\t\n\t// https://firebase.google.com/support/guides/firebase-web\n\t\n\tfunction fetchItem(id, cb) {\n\t  itemRef(id).once('value', function (snapshot) {\n\t    cb(snapshot.val());\n\t  });\n\t}\n\t\n\tfunction fetchItems(ids, cb) {\n\t  var items = [];\n\t  ids.forEach(function (id) {\n\t    fetchItem(id, addItem);\n\t  });\n\t  function addItem(item) {\n\t    items.push(item);\n\t    if (items.length >= ids.length) {\n\t      cb(items);\n\t    }\n\t  }\n\t}\n\t\n\tfunction storiesRef(path) {\n\t  return api.child(path);\n\t}\n\t\n\tfunction itemRef(id) {\n\t  return api.child('item/' + id);\n\t}\n\t\n\tfunction userRef(id) {\n\t  return api.child('user/' + id);\n\t}\n\t\n\tfunction updatesRef() {\n\t  return api.child('updates/items');\n\t}\n\t\n\tmodule.exports = {\n\t  fetchItem: fetchItem,\n\t  fetchItems: fetchItems,\n\t  storiesRef: storiesRef,\n\t  itemRef: itemRef,\n\t  userRef: userRef,\n\t  updatesRef: updatesRef\n\t};\n\n/***/ },\n\n/***/ \"uaYK\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* global fetch */\n\t__webpack_require__(\"BUcb\");\n\t/*\r\n\tA version of HNService which concumes the Firebase REST\r\n\tendpoint (https://www.firebase.com/docs/rest/api/). This\r\n\tis used when a user has enabled 'Offline Mode' in the\r\n\tSettings panel and ensures responses can be easily fetched\r\n\tand cached when paired with Service Worker. This cannot be\r\n\ttrivially done using just Web Sockets with the default\r\n\tFirebase API and provides a sufficient fallback that works.\r\n\t */\n\tvar endPoint = 'https://hacker-news.firebaseio.com/v0';\n\tvar options = {\n\t  method: 'GET',\n\t  headers: {\n\t    'Accept': 'application/json'\n\t  }\n\t};\n\t\n\tfunction storiesRef(path) {\n\t  return fetch(endPoint + '/' + path + '.json', options);\n\t}\n\t\n\tfunction itemRef(id) {\n\t  return fetch(endPoint + '/item/' + id + '.json', options);\n\t}\n\t\n\tfunction itemRefJSON(id) {\n\t  return itemRef(id).then(function (response) {\n\t    return response.json();\n\t  });\n\t}\n\t\n\tfunction userRef(id) {\n\t  return fetch(endPoint + '/user/' + id + '.json', options);\n\t}\n\t\n\tfunction updatesRef() {\n\t  return fetch(endPoint + '/updates/items/' + '.json', options);\n\t}\n\t\n\tfunction fetchItem(id, cb) {\n\t  itemRef(id).then(function (snapshot) {\n\t    cb(snapshot);\n\t  });\n\t}\n\t\n\tfunction fetchItems(ids, cb) {\n\t  var items = [];\n\t  var promises = [];\n\t  ids.forEach(function (id) {\n\t    promises.push(itemRefJSON(id));\n\t  });\n\t  Promise.all(promises).then(function (values) {\n\t    items = values;\n\t    if (items.length >= ids.length) {\n\t      cb(items);\n\t    }\n\t  });\n\t}\n\t\n\tmodule.exports = {\n\t  fetchItem: fetchItem,\n\t  fetchItems: fetchItems,\n\t  storiesRef: storiesRef,\n\t  itemRef: itemRef,\n\t  userRef: userRef,\n\t  updatesRef: updatesRef\n\t};\n\n/***/ },\n\n/***/ \"PJIF\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar CommentThreadStore = __webpack_require__(\"Hwo6\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar debounce = __webpack_require__(\"Y1Gy\");\n\tvar extend = __webpack_require__(\"7S1B\");\n\tvar pluralise = __webpack_require__(\"HSmy\");\n\tvar storage = __webpack_require__(\"VKKs\");\n\t\n\t/**\r\n\t * Load persisted comment thread state.\r\n\t * @return .lastVisit {Date} null if the item hasn't been visited before.\r\n\t * @return .commentCount {Number} 0 if the item hasn't been visited before.\r\n\t * @return .maxCommentId {Number} 0 if the item hasn't been visited before.\r\n\t */\n\tfunction loadState(itemId) {\n\t  var json = storage.get(itemId);\n\t  if (json) {\n\t    return JSON.parse(json);\n\t  }\n\t  return {\n\t    lastVisit: null,\n\t    commentCount: 0,\n\t    maxCommentId: 0\n\t  };\n\t}\n\t\n\tfunction StoryCommentThreadStore(item, onCommentsChanged, options) {\n\t  CommentThreadStore.call(this, item, onCommentsChanged);\n\t  this.startedLoading = Date.now();\n\t\n\t  /** Lookup from a comment id to its parent comment id. */\n\t  this.parents = {};\n\t  /** The number of comments which have loaded. */\n\t  this.commentCount = 0;\n\t  /** The number of new comments which have loaded. */\n\t  this.newCommentCount = 0;\n\t  /** The max comment id seen by the store. */\n\t  this.maxCommentId = 0;\n\t  /** Has the comment thread finished loading? */\n\t  this.loading = true;\n\t  /** The number of comments we're expecting to load. */\n\t  this.expectedComments = item.kids ? item.kids.length : 0;\n\t  /**\r\n\t   * The number of descendants the story has according to the API.\r\n\t   * This count includes deleted comments, which aren't accessible via the API,\r\n\t   * so a thread with deleted comments (example story id: 9273709) will never\r\n\t   * load this number of comments\r\n\t   * However, we still need to persist the last known descendant count in order\r\n\t   * to determine how many new comments there are when displaying the story on a\r\n\t   * list page.\r\n\t   */\n\t  this.itemDescendantCount = item.descendants;\n\t\n\t  var initialState = loadState(item.id);\n\t  /** Time of last visit to the story. */\n\t  this.lastVisit = initialState.lastVisit;\n\t  /** Max comment id on the last visit - determines which comments are new. */\n\t  this.prevMaxCommentId = initialState.maxCommentId;\n\t  /** Is this the user's first time viewing the story? */\n\t  this.isFirstVisit = initialState.lastVisit === null;\n\t\n\t  // Trigger an immediate check for thread load completion if the item was not\n\t  // retrieved from the cache, so is the latest version. This completes page\n\t  // loading immediately for items which have no comments yet.\n\t  if (!options.cached) {\n\t    this.checkLoadCompletion();\n\t  }\n\t}\n\t\n\tStoryCommentThreadStore.loadState = loadState;\n\t\n\tStoryCommentThreadStore.prototype = extend(Object.create(CommentThreadStore.prototype), {\n\t  constructor: StoryCommentThreadStore,\n\t\n\t  /**\r\n\t   * Callback to the item component with updated comment counts, debounced as\r\n\t   * comments will be loading frequently on initial load.\r\n\t   */\n\t  numberOfCommentsChanged: debounce(function () {\n\t    this.onCommentsChanged({ type: 'number' });\n\t  }, 123),\n\t\n\t  /**\r\n\t   * If we don't have a last visit time stored for an item, it must have been\r\n\t   * visited for the first time. Once it finishes loading, establish the last\r\n\t   * visit time and max comment id which will be used to track and display new\r\n\t   * comments.\r\n\t   */\n\t  firstLoadComplete: function firstLoadComplete() {\n\t    this.lastVisit = Date.now();\n\t    this.prevMaxCommentId = this.maxCommentId;\n\t    this.isFirstVisit = false;\n\t    this.onCommentsChanged({ type: 'first_load_complete' });\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Check whether the number of comments has reached the expected number yet.\r\n\t   */\n\t  checkLoadCompletion: function checkLoadCompletion() {\n\t    if (this.loading && this.commentCount >= this.expectedComments) {\n\t      if (false) {\n\t        console.info('Initial load of ' + this.commentCount + ' comment' + pluralise(this.commentCount) + ' for ' + this.itemId + ' took ' + ((Date.now() - this.startedLoading) / 1000).toFixed(2) + 's');\n\t      }\n\t      this.loading = false;\n\t      if (this.isFirstVisit) {\n\t        this.firstLoadComplete();\n\t      } else if (SettingsStore.autoCollapse && this.newCommentCount > 0) {\n\t        this.collapseThreadsWithoutNewComments();\n\t      }\n\t      this._storeState();\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Persist comment thread state.\r\n\t   */\n\t  _storeState: function _storeState() {\n\t    storage.set(this.itemId, JSON.stringify({\n\t      lastVisit: Date.now(),\n\t      commentCount: this.itemDescendantCount,\n\t      maxCommentId: this.maxCommentId\n\t    }));\n\t  },\n\t\n\t\n\t  /**\r\n\t   * The item this comment thread belongs to got updated.\r\n\t   */\n\t  itemUpdated: function itemUpdated(item) {\n\t    this.itemDescendantCount = item.descendants;\n\t  },\n\t\n\t\n\t  /**\r\n\t   * A comment got loaded initially or added later.\r\n\t   */\n\t  commentAdded: function commentAdded(comment) {\n\t    // Deleted comments don't count towards the comment count\n\t    if (comment.deleted) {\n\t      // Adjust the number of comments expected during the initial page load.\n\t      if (this.loading) {\n\t        this.expectedComments--;\n\t        this.checkLoadCompletion();\n\t      }\n\t      return;\n\t    }\n\t\n\t    CommentThreadStore.prototype.commentAdded.call(this, comment);\n\t\n\t    // Dead comments don't contribute to the comment count if showDead is off\n\t    if (comment.dead && !SettingsStore.showDead) {\n\t      this.expectedComments--;\n\t    } else {\n\t      this.commentCount++;\n\t    }\n\t    // Add the number of kids the comment has to the expected total for the\n\t    // initial load.\n\t    if (this.loading && comment.kids) {\n\t      this.expectedComments += comment.kids.length;\n\t    }\n\t    // Register the comment as new if it's new, unless it's dead and showDead is off\n\t    if (this.prevMaxCommentId > 0 && comment.id > this.prevMaxCommentId && (!comment.dead || SettingsStore.showDead)) {\n\t      this.newCommentCount++;\n\t      this.isNew[comment.id] = true;\n\t    }\n\t    // Keep track of the biggest comment id seen\n\t    if (comment.id > this.maxCommentId) {\n\t      this.maxCommentId = comment.id;\n\t    }\n\t    // We don't want the story to be part of the comment parent hierarchy\n\t    if (comment.parent !== this.itemId) {\n\t      this.parents[comment.id] = comment.parent;\n\t    }\n\t\n\t    this.numberOfCommentsChanged();\n\t    if (this.loading) {\n\t      this.checkLoadCompletion();\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * A comment which hasn't loaded yet is being delayed.\r\n\t   */\n\t  commentDelayed: function commentDelayed(commentId) {\n\t    // Don't wait for delayed comments\n\t    this.expectedComments--;\n\t  },\n\t\n\t\n\t  /**\r\n\t   * A comment which wasn't previously deleted became deleted.\r\n\t   */\n\t  commentDeleted: function commentDeleted(comment) {\n\t    CommentThreadStore.prototype.commentDeleted.call(this, comment);\n\t    this.commentCount--;\n\t    if (this.isNew[comment.id]) {\n\t      this.newCommentCount--;\n\t      delete this.isNew[comment.id];\n\t    }\n\t    delete this.parents[comment.id];\n\t    // Trigger debounced callbacks\n\t    this.numberOfCommentsChanged();\n\t  },\n\t\n\t\n\t  /**\r\n\t   * A comment which wasn't previously dead became dead.\r\n\t   */\n\t  commentDied: function commentDied(comment) {\n\t    if (!SettingsStore.showDead) {\n\t      this.commentCount--;\n\t      if (this.isNew[comment.id]) {\n\t        this.newCommentCount--;\n\t        delete this.isNew[comment.id];\n\t      }\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Change the expected number of comments if an update was received during\r\n\t   * initial loding and trigger a re-check of loading completion.\r\n\t   */\n\t  adjustExpectedComments: function adjustExpectedComments(change) {\n\t    this.expectedComments += change;\n\t    this.checkLoadCompletion();\n\t  },\n\t  collapseThreadsWithoutNewComments: function collapseThreadsWithoutNewComments() {\n\t    // Create an id lookup for comments which have a new comment as one of their\n\t    // descendants. New comments themselves are not added to the lookup.\n\t    var newCommentIds = Object.keys(this.isNew);\n\t    var hasNewComments = {};\n\t    for (var i = 0, l = newCommentIds.length; i < l; i++) {\n\t      var parent = this.parents[newCommentIds[i]];\n\t      while (parent) {\n\t        // Stop when we hit one we've seen before\n\t        if (hasNewComments[parent]) {\n\t          break;\n\t        }\n\t        hasNewComments[parent] = true;\n\t        parent = this.parents[parent];\n\t      }\n\t    }\n\t\n\t    // Walk the tree of comments one level at a time, only walking children to\n\t    // comments we know have new comment descendants, to find subtrees which\n\t    // don't have new comments.\n\t    // Other comments are marked for collapsing unless they are themselves a\n\t    // new comment (in which case all their replies must be new too).\n\t    var shouldCollapse = {};\n\t    var commentIds = this.children[this.itemId];\n\t    while (commentIds.length) {\n\t      var nextCommentIds = [];\n\t      for (i = 0, l = commentIds.length; i < l; i++) {\n\t        var commentId = commentIds[i];\n\t        if (!hasNewComments[commentId]) {\n\t          if (!this.isNew[commentId]) {\n\t            shouldCollapse[commentId] = true;\n\t          }\n\t        } else {\n\t          var childCommentIds = this.children[commentId];\n\t          if (childCommentIds.length) {\n\t            nextCommentIds.push.apply(nextCommentIds, childCommentIds);\n\t          }\n\t        }\n\t      }\n\t      commentIds = nextCommentIds;\n\t    }\n\t\n\t    this.isCollapsed = shouldCollapse;\n\t    this.onCommentsChanged({ type: 'collapse' });\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Merk the thread as read.\r\n\t   */\n\t  markAsRead: function markAsRead() {\n\t    this.lastVisit = Date.now();\n\t    this.newCommentCount = 0;\n\t    this.prevMaxCommentId = this.maxCommentId;\n\t    this.isNew = {};\n\t    this._storeState();\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Persist comment thread state and perform any necessary internal cleanup.\r\n\t   */\n\t  dispose: function dispose() {\n\t    // Cancel debounced callbacks in case any are pending\n\t    this.numberOfCommentsChanged.cancel();\n\t    this._storeState();\n\t  }\n\t});\n\t\n\tmodule.exports = StoryCommentThreadStore;\n\n/***/ },\n\n/***/ \"Hwo6\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar extend = __webpack_require__(\"7S1B\");\n\t\n\tfunction CommentThreadStore(item, onCommentsChanged) {\n\t  this.itemId = item.id;\n\t  this.onCommentsChanged = onCommentsChanged;\n\t\n\t  /**\r\n\t   * Lookup from a comment id to its child comment ids.\r\n\t   * @type {Object.<id,Array.<Number>>}\r\n\t   */\n\t  this.children = {};\n\t  this.children[item.id] = [];\n\t\n\t  /**\r\n\t   * Lookup for new comment ids. Will only contain true.\r\n\t   * @type {Object.<id,Boolean>}\r\n\t   */\n\t  this.isNew = {};\n\t\n\t  /**\r\n\t   * Lookup for collapsed state of comment ids. May contain true or false.\r\n\t   * @type {Object.<id,Boolean>}\r\n\t   */\n\t  this.isCollapsed = {};\n\t}\n\t\n\textend(CommentThreadStore.prototype, {\n\t  /**\r\n\t   * Get counts of children and new comments under the given comment.\r\n\t   * @return .children {Number}\r\n\t   * @return .newComments {Number}\r\n\t   */\n\t  getChildCounts: function getChildCounts(comment) {\n\t    var childCount = 0;\n\t    var newCommentCount = 0;\n\t    var nodes = [comment.id];\n\t\n\t    while (nodes.length) {\n\t      var nextNodes = [];\n\t      for (var i = 0, l = nodes.length; i < l; i++) {\n\t        var nodeChildren = this.children[nodes[i]];\n\t        if (nodeChildren.length) {\n\t          nextNodes.push.apply(nextNodes, nodeChildren);\n\t        }\n\t      }\n\t      for (i = 0, l = nextNodes.length; i < l; i++) {\n\t        if (this.isNew[nextNodes[i]]) {\n\t          newCommentCount++;\n\t        }\n\t      }\n\t      childCount += nextNodes.length;\n\t      nodes = nextNodes;\n\t    }\n\t\n\t    return {\n\t      children: childCount,\n\t      newComments: newCommentCount\n\t    };\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Register a comment's appearance in the thread.\r\n\t   */\n\t  commentAdded: function commentAdded(comment) {\n\t    if (comment.deleted) {\n\t      return;\n\t    }\n\t\n\t    this.children[comment.id] = [];\n\t    this.children[comment.parent].push(comment.id);\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Register a comment's deletion from the thread.\r\n\t   */\n\t  commentDeleted: function commentDeleted(comment) {\n\t    // Comments which initially failed to load (null from Firebase API) can be\n\t    // deleted by the time the API catches up.\n\t    if (!comment) {\n\t      return;\n\t    }\n\t\n\t    var siblings = this.children[comment.parent];\n\t    siblings.splice(siblings.indexOf(comment.id), 1);\n\t  },\n\t  toggleCollapse: function toggleCollapse(commentId) {\n\t    this.isCollapsed[commentId] = !this.isCollapsed[commentId];\n\t    this.onCommentsChanged({ type: 'collapse' });\n\t  }\n\t});\n\t\n\tmodule.exports = CommentThreadStore;\n\n/***/ },\n\n/***/ \"7S1B\":\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction extend(dest, src1, src2) {\n\t  var props = Object.keys(src1);\n\t  for (var i = 0, l = props.length; i < l; i++) {\n\t    dest[props[i]] = src1[props[i]];\n\t  }\n\t  if (src2) {\n\t    props = Object.keys(src2);\n\t    for (i = 0, l = props.length; i < l; i++) {\n\t      dest[props[i]] = src2[props[i]];\n\t    }\n\t  }\n\t  return dest;\n\t}\n\t\n\tmodule.exports = extend;\n\n/***/ },\n\n/***/ \"NPdQ\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar extend = __webpack_require__(\"7S1B\");\n\tvar storage = __webpack_require__(\"VKKs\");\n\t\n\tvar STORAGE_KEY = 'settings';\n\t\n\tvar SettingsStore = {\n\t  autoCollapse: true,\n\t  replyLinks: true,\n\t  showDead: false,\n\t  showDeleted: false,\n\t  titleFontSize: 18,\n\t  listSpacing: 16,\n\t  offlineMode: false,\n\t\n\t  load: function load() {\n\t    var json = storage.get(STORAGE_KEY);\n\t    if (json) {\n\t      extend(this, JSON.parse(json));\n\t    }\n\t  },\n\t  save: function save() {\n\t    storage.set(STORAGE_KEY, JSON.stringify({\n\t      autoCollapse: this.autoCollapse,\n\t      replyLinks: this.replyLinks,\n\t      showDead: this.showDead,\n\t      showDeleted: this.showDeleted,\n\t      titleFontSize: this.titleFontSize,\n\t      listSpacing: this.listSpacing,\n\t      offlineMode: this.offlineMode\n\t    }));\n\t  }\n\t};\n\t\n\tmodule.exports = SettingsStore;\n\n/***/ },\n\n/***/ \"VKKs\":\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  get: function get(key, defaultValue) {\n\t    if (typeof window === 'undefined') {\n\t      return defaultValue;\n\t    } else {\n\t      var value = window.localStorage[key];\n\t      return typeof value != 'undefined' ? value : defaultValue;\n\t    }\n\t  },\n\t  set: function set(key, value) {\n\t    if (typeof window !== 'undefined') {\n\t      window.localStorage[key] = value;\n\t    }\n\t  }\n\t};\n\n/***/ },\n\n/***/ \"Y1Gy\":\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\r\n\t * Based on the implementation of _.debounce() from Underscore.js 1.7.0\r\n\t * http://underscorejs.org\r\n\t * (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n\t * Distributed under the MIT license.\r\n\t *\r\n\t * Returns a function, that, as long as it continues to be invoked, will not\r\n\t * be triggered. The function will be called after it stops being called for\r\n\t * N milliseconds. If `immediate` is passed, trigger the function on the\r\n\t * leading edge, instead of the trailing.\r\n\t *\r\n\t * The returned function has a .cancel() function which can be used to prevent\r\n\t * the debounced functiom being called.\r\n\t */\n\tfunction cancellableDebounce(func, wait, immediate) {\n\t  var timeout, args, context, timestamp, result;\n\t\n\t  var later = function later() {\n\t    var last = Date.now() - timestamp;\n\t    if (last < wait && last > 0) {\n\t      timeout = setTimeout(later, wait - last);\n\t    } else {\n\t      timeout = null;\n\t      if (!immediate) {\n\t        result = func.apply(context, args);\n\t        if (!timeout) {\n\t          context = args = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  var debounced = function debounced() {\n\t    context = this;\n\t    args = arguments;\n\t    timestamp = Date.now();\n\t    var callNow = immediate && !timeout;\n\t    if (!timeout) {\n\t      timeout = setTimeout(later, wait);\n\t    }\n\t    if (callNow) {\n\t      result = func.apply(context, args);\n\t      context = args = null;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  debounced.cancel = function () {\n\t    if (timeout) {\n\t      clearTimeout(timeout);\n\t    }\n\t  };\n\t\n\t  return debounced;\n\t}\n\t\n\tmodule.exports = cancellableDebounce;\n\n/***/ },\n\n/***/ \"HSmy\":\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction pluralise(howMany, suffixes) {\n\t  return (suffixes || ',s').split(',')[howMany === 1 ? 0 : 1];\n\t}\n\t\n\tmodule.exports = pluralise;\n\n/***/ },\n\n/***/ \"bRBh\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {'use strict';\n\t\n\tvar HNService = __webpack_require__(\"VIGu\");\n\tvar HNServiceRest = __webpack_require__(\"uaYK\");\n\t\n\tvar StoryStore = __webpack_require__(\"FA3V\");\n\tvar UpdatesStore = __webpack_require__(\"fsMb\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\tvar commentParentLookup = {};\n\tvar titleCache = {};\n\t\n\tfunction fetchCommentParent(comment, cb, result) {\n\t  var commentId = comment.id;\n\t  var parentId = comment.parent;\n\t\n\t  while (commentParentLookup[parentId] || titleCache[parentId]) {\n\t    // We just saved ourselves an item fetch\n\t    result.itemCount++;\n\t    result.cacheHits++;\n\t\n\t    // The parent is a known non-comment\n\t    if (titleCache[parentId]) {\n\t      if (result.itemCount === 1) {\n\t        result.parent = titleCache[parentId];\n\t      }\n\t      result.op = titleCache[parentId];\n\t      cb(result);\n\t      return;\n\t    }\n\t\n\t    // The parent is a known comment\n\t    if (commentParentLookup[parentId]) {\n\t      if (result.itemCount === 1) {\n\t        result.parent = { id: parentId, type: 'comment' };\n\t      }\n\t      // Set the parent comment's ids up for the next iteration\n\t      commentId = parentId;\n\t      parentId = commentParentLookup[parentId];\n\t    }\n\t  }\n\t\n\t  // The parent of the current comment isn't known, so we'll have to fetch it\n\t  ItemStore.getItem(parentId, function (parent) {\n\t    result.itemCount++;\n\t    // Add the current comment's parent to the lookup for next time\n\t    commentParentLookup[commentId] = parentId;\n\t    if (parent.type === 'comment') {\n\t      commentParentLookup[parent.id] = parent.parent;\n\t    }\n\t    processCommentParent(parent, cb, result);\n\t  }, result);\n\t}\n\t\n\tfunction processCommentParent(item, cb, result) {\n\t  if (result.itemCount === 1) {\n\t    result.parent = item;\n\t  }\n\t  if (item.type !== 'comment') {\n\t    result.op = item;\n\t    titleCache[item.id] = {\n\t      id: item.id,\n\t      type: item.type,\n\t      title: item.title\n\t    };\n\t    cb(result);\n\t  } else {\n\t    fetchCommentParent(item, cb, result);\n\t  }\n\t}\n\t\n\tvar ItemStore = {\n\t  getItem: function getItem(id, cb, result) {\n\t    var cachedItem = this.getCachedItem(id);\n\t    if (cachedItem) {\n\t      if (result) {\n\t        result.cacheHits++;\n\t      }\n\t      setImmediate(cb, cachedItem);\n\t    } else {\n\t      if (SettingsStore.offlineMode) {\n\t        HNServiceRest.fetchItem(id, cb);\n\t      } else {\n\t        HNService.fetchItem(id, cb);\n\t      }\n\t    }\n\t  },\n\t  getCachedItem: function getCachedItem(id) {\n\t    return StoryStore.getItem(id) || UpdatesStore.getItem(id) || null;\n\t  },\n\t  getCachedStory: function getCachedStory(id) {\n\t    return StoryStore.getItem(id) || UpdatesStore.getStory(id) || null;\n\t  },\n\t  fetchCommentAncestors: function fetchCommentAncestors(comment, cb) {\n\t    var startTime = Date.now();\n\t    var result = { itemCount: 0, cacheHits: 0 };\n\t    fetchCommentParent(comment, function () {\n\t      result.timeTaken = Date.now() - startTime;\n\t      setImmediate(cb, result);\n\t    }, result);\n\t  }\n\t};\n\t\n\tmodule.exports = ItemStore;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"AQBu\").setImmediate))\n\n/***/ },\n\n/***/ \"FA3V\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _require = __webpack_require__(\"HBrH\"),\n\t    EventEmitter = _require.EventEmitter;\n\t\n\tvar HNService = __webpack_require__(\"VIGu\");\n\tvar HNServiceRest = __webpack_require__(\"uaYK\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar extend = __webpack_require__(\"7S1B\");\n\t\n\t/**\r\n\t * Firebase reference used to stream updates - only one StoryStore instance can\r\n\t * be active at a time.\r\n\t */\n\tvar firebaseRef = null;\n\t\n\t// Cache objects shared among StoryStore instances, also accessible via static\n\t// functions on the StoryStore constructor.\n\t\n\t/**\r\n\t * Story ids by type, in rank order. Persisted to sessionStorage.\r\n\t * @type Object.<type, Array.<id>>\r\n\t */\n\tvar idCache = {};\n\t\n\t/**\r\n\t * Item cache. Persisted to sessionStorage.\r\n\t * @type Object.<id, item>\r\n\t */\n\tvar itemCache = {};\n\t\n\t/**\r\n\t * Story items in rank order for display, by type.\r\n\t * @type Object.<type, Array.<item>>\r\n\t */\n\tvar storyLists = {};\n\t\n\t/**\r\n\t * Populate the story list for the given story type from the cache.\r\n\t */\n\tfunction populateStoryList(type) {\n\t  var ids = idCache[type];\n\t  var storyList = storyLists[type];\n\t  for (var i = 0, l = ids.length; i < l; i++) {\n\t    storyList[i] = itemCache[ids[i]] || null;\n\t  }\n\t}\n\t\n\tfunction parseJSON(json, defaultValue) {\n\t  return json ? JSON.parse(json) : defaultValue;\n\t}\n\t\n\tvar StoryStore = function (_EventEmitter) {\n\t  _inherits(StoryStore, _EventEmitter);\n\t\n\t  function StoryStore(type) {\n\t    _classCallCheck(this, StoryStore);\n\t\n\t    var _this = _possibleConstructorReturn(this, (StoryStore.__proto__ || Object.getPrototypeOf(StoryStore)).call(this));\n\t\n\t    _this.type = type;\n\t\n\t    // Ensure cache objects for this type are initialised\n\t    if (!(type in idCache)) {\n\t      idCache[type] = [];\n\t    }\n\t    if (!(type in storyLists)) {\n\t      storyLists[type] = [];\n\t      populateStoryList(type);\n\t    }\n\t\n\t    // Pre-bind event handlers per instance\n\t    _this.onStorage = _this.onStorage.bind(_this);\n\t    _this.onStoriesUpdated = _this.onStoriesUpdated.bind(_this);\n\t    return _this;\n\t  }\n\t\n\t  _createClass(StoryStore, [{\n\t    key: 'getState',\n\t    value: function getState() {\n\t      return {\n\t        ids: idCache[this.type],\n\t        stories: storyLists[this.type]\n\t      };\n\t    }\n\t  }, {\n\t    key: 'itemUpdated',\n\t    value: function itemUpdated(item, index) {\n\t      storyLists[this.type][index] = item;\n\t      itemCache[item.id] = item;\n\t    }\n\t\n\t    /**\r\n\t     * Emit an item id event if a storage key corresponding to an item in the\r\n\t     * cache has changed.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'onStorage',\n\t    value: function onStorage(e) {\n\t      if (itemCache[e.key]) {\n\t        this.emit(e.key);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Handle story id snapshots from Firebase.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'onStoriesUpdated',\n\t    value: function onStoriesUpdated(snapshot) {\n\t      if (SettingsStore.offlineMode) {\n\t        idCache[this.type] = snapshot;\n\t      } else {\n\t        idCache[this.type] = snapshot.val();\n\t      }\n\t      populateStoryList(this.type);\n\t      this.emit('update', this.getState());\n\t    }\n\t  }, {\n\t    key: 'start',\n\t    value: function start() {\n\t      if (typeof window === 'undefined') return;\n\t      if (SettingsStore.offlineMode) {\n\t        HNServiceRest.storiesRef(this.type).then(function (res) {\n\t          return res.json();\n\t        }).then(function (snapshot) {\n\t          this.onStoriesUpdated(snapshot);\n\t        }.bind(this));\n\t      } else {\n\t        firebaseRef = HNService.storiesRef(this.type);\n\t        firebaseRef.on('value', this.onStoriesUpdated);\n\t      }\n\t      window.addEventListener('storage', this.onStorage);\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop() {\n\t      if (firebaseRef !== null) {\n\t        if (!SettingsStore.offlineMode) {\n\t          firebaseRef.off();\n\t        }\n\t        firebaseRef = null;\n\t      }\n\t      if (typeof window === 'undefined') return;\n\t      window.removeEventListener('storage', this.onStorage);\n\t    }\n\t  }]);\n\t\n\t  return StoryStore;\n\t}(EventEmitter);\n\t\n\t// Static, cache-related functions\n\t\n\t\n\textend(StoryStore, {\n\t  /**\r\n\t   * Get an item from the cache.\r\n\t   */\n\t  getItem: function getItem(id) {\n\t    return itemCache[id] || null;\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Deserialise caches from sessionStorage.\r\n\t   */\n\t  loadSession: function loadSession() {\n\t    if (typeof window === 'undefined') return;\n\t    if (SettingsStore.offlineMode) {\n\t      idCache = parseJSON(window.localStorage.idCache, {});\n\t      itemCache = parseJSON(window.localStorage.itemCache, {});\n\t    } else {\n\t      idCache = parseJSON(window.sessionStorage.idCache, {});\n\t      itemCache = parseJSON(window.sessionStorage.itemCache, {});\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Serialise caches to sessionStorage as JSON.\r\n\t   */\n\t  saveSession: function saveSession() {\n\t    if (typeof window === 'undefined') return;\n\t    if (SettingsStore.offlineMode) {\n\t      window.localStorage.setItem('idCache', JSON.stringify(idCache));\n\t      window.localStorage.setItem('itemCache', JSON.stringify(itemCache));\n\t    } else {\n\t      window.sessionStorage.idCache = JSON.stringify(idCache);\n\t      window.sessionStorage.itemCache = JSON.stringify(itemCache);\n\t    }\n\t  }\n\t});\n\t\n\tmodule.exports = StoryStore;\n\n/***/ },\n\n/***/ \"fsMb\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(\"HBrH\").EventEmitter;\n\t\n\tvar HNService = __webpack_require__(\"VIGu\");\n\tvar HNServiceRest = __webpack_require__(\"uaYK\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar _require = __webpack_require__(\"FN8c\"),\n\t    UPDATES_CACHE_SIZE = _require.UPDATES_CACHE_SIZE;\n\t\n\tvar extend = __webpack_require__(\"7S1B\");\n\t\n\t/**\r\n\t * Firebase reference used to stream updates.\r\n\t */\n\tvar updatesRef = null;\n\t\n\t/**\r\n\t * Contains item id -> item cache objects. Persisted to sessionStorage.\r\n\t * @prop .comments {Object.<id,item>} comments cache.\r\n\t * @prop .stories {Object.<id,item>} story cache.\r\n\t */\n\tvar updatesCache = null;\n\t\n\t/**\r\n\t * Lists of items in reverse chronological order for display.\r\n\t * @prop .comments {Array.<item>} comment updates.\r\n\t * @prop .stories {Array.<item>} story updates.\r\n\t */\n\tvar updates = {};\n\t\n\tfunction sortByTimeDesc(a, b) {\n\t  return b.time - a.time;\n\t}\n\t\n\tfunction cacheObjToSortedArray(obj) {\n\t  var arr = Object.keys(obj).map(function (id) {\n\t    return obj[id];\n\t  });\n\t  arr.sort(sortByTimeDesc);\n\t  return arr;\n\t}\n\t\n\t/**\r\n\t * Populate lists of updates for display from the cache.\r\n\t */\n\tfunction populateUpdates() {\n\t  updates.comments = processCacheObj(updatesCache.comments);\n\t  updates.stories = processCacheObj(updatesCache.stories);\n\t}\n\t\n\t/**\r\n\t * Create an array of items from a cache object, sorted in reverse chronological\r\n\t * order. Evict the oldest items from the cache if it's grown above\r\n\t * UPDATES_CACHE_SIZE.\r\n\t */\n\tfunction processCacheObj(cacheObj) {\n\t  var arr = cacheObjToSortedArray(cacheObj);\n\t  arr.splice(UPDATES_CACHE_SIZE, Math.max(0, arr.length - UPDATES_CACHE_SIZE)).forEach(function (item) {\n\t    delete cacheObj[item.id];\n\t  });\n\t  return arr;\n\t}\n\t\n\t/**\r\n\t * Lookup to filter out any items which appear in the updates feed which can't\r\n\t * be displayed by the Updates component.\r\n\t */\n\tvar updateItemTypes = {\n\t  comment: true,\n\t  job: true,\n\t  poll: true,\n\t  story: true\n\t};\n\t\n\t/**\r\n\t * Process incoming items from the update stream.\r\n\t */\n\tfunction handleUpdateItems(items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    var item = items[i];\n\t    // Silently ignore deleted items (because irony)\n\t    if (item.deleted) {\n\t      continue;\n\t    }\n\t\n\t    if (typeof updateItemTypes[item.type] == 'undefined') {\n\t      if (false) {\n\t        console.warn(\"An item which can't be displayed by the Updates component was \" + 'received in the updates stream: ' + JSON.stringify(item));\n\t      }\n\t      continue;\n\t    }\n\t\n\t    if (item.type === 'comment') {\n\t      updatesCache.comments[item.id] = item;\n\t    } else {\n\t      updatesCache.stories[item.id] = item;\n\t    }\n\t  }\n\t  populateUpdates();\n\t  UpdatesStore.emit('updates', updates);\n\t}\n\t\n\tvar UpdatesStore = extend(new EventEmitter(), {\n\t  loadSession: function loadSession() {\n\t    if (typeof window === 'undefined') return;\n\t    var json = window.sessionStorage.updates;\n\t    updatesCache = json ? JSON.parse(json) : { comments: {}, stories: {} };\n\t    populateUpdates();\n\t  },\n\t  saveSession: function saveSession() {\n\t    if (typeof window === 'undefined') return;\n\t    window.sessionStorage.updates = JSON.stringify(updatesCache);\n\t  },\n\t  start: function start() {\n\t    if (updatesRef === null) {\n\t      if (SettingsStore.offlineMode) {\n\t        HNServiceRest.updatesRef().then(function (res) {\n\t          return res.json();\n\t        }).then(function (snapshot) {\n\t          HNServiceRest.fetchItems(snapshot, handleUpdateItems);\n\t        });\n\t      } else {\n\t        updatesRef = HNService.updatesRef();\n\t        updatesRef.on('value', function (snapshot) {\n\t          HNService.fetchItems(snapshot.val(), handleUpdateItems);\n\t        });\n\t      }\n\t    }\n\t  },\n\t  stop: function stop() {\n\t    if (!SettingsStore.offlineMode) {\n\t      updatesRef.off();\n\t      updatesRef = null;\n\t    }\n\t  },\n\t  getUpdates: function getUpdates() {\n\t    return updates;\n\t  },\n\t  getItem: function getItem(id) {\n\t    return updatesCache.comments[id] || updatesCache.stories[id] || null;\n\t  },\n\t  getComment: function getComment(id) {\n\t    return updatesCache.comments[id] || null;\n\t  },\n\t  getStory: function getStory(id) {\n\t    return updatesCache.stories[id] || null;\n\t  }\n\t});\n\tUpdatesStore.off = UpdatesStore.removeListener;\n\t\n\tmodule.exports = UpdatesStore;\n\n/***/ },\n\n/***/ \"FN8c\":\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  ITEMS_PER_PAGE: 30,\n\t  SITE_TITLE: 'React HN',\n\t  UPDATES_CACHE_SIZE: 500\n\t};\n\n/***/ },\n\n/***/ \"VThE\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar CommentMixin = __webpack_require__(\"bFfS\");\n\t\n\tvar cx = __webpack_require__(\"H9Jo\");\n\t\n\t/**\r\n\t * Displays a standalone comment passed as a prop.\r\n\t */\n\tvar DisplayComment = React.createClass({\n\t  displayName: 'DisplayComment',\n\t\n\t  mixins: [CommentMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      op: {},\n\t      parent: { type: 'comment' }\n\t    };\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    this.fetchAncestors(this.props.comment);\n\t  },\n\t  render: function render() {\n\t    if (this.props.comment.deleted) {\n\t      return null;\n\t    }\n\t    if (this.props.comment.dead && !SettingsStore.showDead) {\n\t      return null;\n\t    }\n\t\n\t    var comment = this.props.comment;\n\t    var className = cx('Comment Comment--level0', {\n\t      'Comment--dead': comment.dead\n\t    });\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        this.renderCommentMeta(comment, {\n\t          link: true,\n\t          parent: !!this.state.parent.id && !!this.state.op.id && comment.parent !== this.state.op.id,\n\t          op: !!this.state.op.id\n\t        }),\n\t        this.renderCommentText(comment, { replyLink: false })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = DisplayComment;\n\n/***/ },\n\n/***/ \"bFfS\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar Link = __webpack_require__(\"mEw0\");\n\tvar TimeAgo = __webpack_require__(\"z3IR\").default;\n\t\n\tvar ItemStore = __webpack_require__(\"bRBh\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar Spinner = __webpack_require__(\"OieW\");\n\t\n\tvar pluralise = __webpack_require__(\"HSmy\");\n\t\n\tvar CommentMixin = {\n\t  fetchAncestors: function fetchAncestors(comment) {\n\t    var _this = this;\n\t\n\t    ItemStore.fetchCommentAncestors(comment, function (result) {\n\t      if (false) {\n\t        console.info('fetchAncestors(' + comment.id + ') took ' + result.timeTaken + ' ms for ' + result.itemCount + ' item' + pluralise(result.itemCount) + ' with ' + result.cacheHits + ' cache hit' + pluralise(result.cacheHits) + ' (' + (result.cacheHits / result.itemCount * 100).toFixed(1) + '%)');\n\t      }\n\t      if (!_this.isMounted()) {\n\t        if (false) {\n\t          console.info(\"...but the comment isn't mounted\");\n\t        }\n\t        // Too late - the comment or the user has moved elsewhere\n\t        return;\n\t      }\n\t      _this.setState({\n\t        parent: result.parent,\n\t        op: result.op\n\t      });\n\t    });\n\t  },\n\t  renderCommentLoading: function renderCommentLoading(comment) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Comment Comment--loading Comment--level' + this.props.level },\n\t      (this.props.loadingSpinner || comment.delayed) && React.createElement(Spinner, { size: '20' }),\n\t      comment.delayed && React.createElement(\n\t        'div',\n\t        { className: 'Comment__text' },\n\t        'Unable to load comment \\u2013 this usually indicates the author has configured a delay. Trying again in 30 seconds.'\n\t      )\n\t    );\n\t  },\n\t  renderCommentDeleted: function renderCommentDeleted(comment, options) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: options.className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Comment__meta' },\n\t          '[deleted] | ',\n\t          React.createElement(\n\t            'a',\n\t            { href: 'https://news.ycombinator.com/item?id=' + comment.id },\n\t            'view on Hacker News'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  },\n\t  renderError: function renderError(comment, options) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: options.className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Comment__meta' },\n\t          '[error] | comment is ',\n\t          JSON.stringify(comment),\n\t          ' | ',\n\t          React.createElement(\n\t            'a',\n\t            { href: 'https://news.ycombinator.com/item?id=' + options.id },\n\t            'view on Hacker News'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  },\n\t  renderCollapseControl: function renderCollapseControl(collapsed) {\n\t    return React.createElement(\n\t      'span',\n\t      { className: 'Comment__collapse', onClick: this.toggleCollapse, onKeyPress: this.toggleCollapse, tabIndex: '0' },\n\t      '[',\n\t      collapsed ? '+' : '',\n\t      ']'\n\t    );\n\t  },\n\t\n\t\n\t  /**\r\n\t   * @param options.collapsible {Boolean} if true, assumes this.toggleCollspse()\r\n\t   * @param options.collapsed {Boolean}\r\n\t   * @param options.link {Boolean}\r\n\t   * @param options.parent {Boolean} if true, assumes this.state.parent\r\n\t   * @param options.op {Boolean} if true, assumes this.state.op\r\n\t   * @param options.childCounts {Object} with .children and .newComments\r\n\t   */\n\t  renderCommentMeta: function renderCommentMeta(comment, options) {\n\t    if (comment.dead && !SettingsStore.showDead) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Comment__meta' },\n\t        options.collapsible && this.renderCollapseControl(options.collapsed),\n\t        options.collapsible && ' ',\n\t        '[dead]',\n\t        options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren'),\n\t        options.childCounts && options.childCounts.newComments > 0 && ', ',\n\t        options.childCounts && options.childCounts.newComments > 0 && React.createElement(\n\t          'em',\n\t          null,\n\t          options.childCounts.newComments,\n\t          ' new'\n\t        ),\n\t        options.childCounts && ')'\n\t      );\n\t    }\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Comment__meta' },\n\t      options.collapsible && this.renderCollapseControl(options.collapsed),\n\t      options.collapsible && ' ',\n\t      React.createElement(\n\t        Link,\n\t        { to: '/user/' + comment.by, className: 'Comment__user' },\n\t        comment.by\n\t      ),\n\t      ' ',\n\t      React.createElement(TimeAgo, { date: comment.time * 1000 }),\n\t      options.link && ' | ',\n\t      options.link && React.createElement(\n\t        Link,\n\t        { to: '/comment/' + comment.id },\n\t        'link'\n\t      ),\n\t      options.parent && ' | ',\n\t      options.parent && React.createElement(\n\t        Link,\n\t        { to: '/' + this.state.parent.type + '/' + comment.parent },\n\t        'parent'\n\t      ),\n\t      options.op && ' | on: ',\n\t      options.op && React.createElement(\n\t        Link,\n\t        { to: '/' + this.state.op.type + '/' + this.state.op.id },\n\t        this.state.op.title\n\t      ),\n\t      comment.dead && ' | [dead]',\n\t      options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren'),\n\t      options.childCounts && options.childCounts.newComments > 0 && ', ',\n\t      options.childCounts && options.childCounts.newComments > 0 && React.createElement(\n\t        'em',\n\t        null,\n\t        options.childCounts.newComments,\n\t        ' new'\n\t      ),\n\t      options.childCounts && ')'\n\t    );\n\t  },\n\t  renderCommentText: function renderCommentText(comment, options) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Comment__text' },\n\t      !comment.dead || SettingsStore.showDead ? React.createElement('div', { dangerouslySetInnerHTML: { __html: comment.text } }) : '[dead]',\n\t      SettingsStore.replyLinks && options.replyLink && !comment.dead && React.createElement(\n\t        'p',\n\t        null,\n\t        React.createElement(\n\t          'a',\n\t          { href: 'https://news.ycombinator.com/reply?id=' + comment.id },\n\t          'reply'\n\t        )\n\t      )\n\t    );\n\t  }\n\t};\n\t\n\tmodule.exports = CommentMixin;\n\n/***/ },\n\n/***/ \"OieW\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\t// TODO Implement GIF-based fallback for IE9 and another non-animating browsers\n\t//      See https://github.com/tobiasahlin/SpinKit for how-to\n\tvar Spinner = React.createClass({\n\t  displayName: 'Spinner',\n\t  getDefaultProps: function getDefaultProps() {\n\t    return { size: 6, spacing: 2 };\n\t  },\n\t  render: function render() {\n\t    var bounceSize = this.props.size + 'px';\n\t    var bounceStyle = { height: bounceSize, width: bounceSize, marginRight: this.props.spacing + 'px' };\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Spinner', style: { width: (Number(this.props.size) + Number(this.props.spacing)) * 3 + 'px' } },\n\t      React.createElement('div', { className: 'bounce1', style: bounceStyle }),\n\t      React.createElement('div', { className: 'bounce2', style: bounceStyle }),\n\t      React.createElement('div', { className: 'bounce3', style: bounceStyle })\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Spinner;\n\n/***/ },\n\n/***/ \"H9Jo\":\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * Creates a className string including some class names conditionally.\r\n\t * @param {string=} staticClassName class name(s) which should always be\r\n\t *   included.\r\n\t * @param {Object.<string, *>} conditionalClassNames an object mapping class\r\n\t *   names to a value which indicates if the class name should be included -\r\n\t *   class names will be included if their corresponding value is truthy.\r\n\t * @return {string}\r\n\t */\n\tfunction buildClassName(staticClassName, conditionalClassNames) {\n\t  var classNames = [];\n\t  if (typeof conditionalClassNames == 'undefined') {\n\t    conditionalClassNames = staticClassName;\n\t  } else {\n\t    classNames.push(staticClassName);\n\t  }\n\t  var classNameKeys = Object.keys(conditionalClassNames);\n\t  for (var i = 0, l = classNameKeys.length; i < l; i++) {\n\t    if (conditionalClassNames[classNameKeys[i]]) {\n\t      classNames.push(classNameKeys[i]);\n\t    }\n\t  }\n\t  return classNames.join(' ');\n\t}\n\t\n\tmodule.exports = buildClassName;\n\n/***/ },\n\n/***/ \"j+W0\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar ReactFireMixin = __webpack_require__(\"ZZqC\");\n\t\n\tvar HNService = __webpack_require__(\"VIGu\");\n\t\n\tvar Spinner = __webpack_require__(\"OieW\");\n\t\n\tvar pluralise = __webpack_require__(\"HSmy\");\n\t\n\tvar PollOption = React.createClass({\n\t  displayName: 'PollOption',\n\t\n\t  mixins: [ReactFireMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return { pollopt: {} };\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindAsObject(HNService.itemRef(this.props.id), 'pollopt');\n\t  },\n\t  render: function render() {\n\t    var pollopt = this.state.pollopt;\n\t    if (!pollopt.id) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'PollOption PollOption--loading' },\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'PollOption' },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'PollOption__text' },\n\t        pollopt.text\n\t      ),\n\t      React.createElement(\n\t        'div',\n\t        { className: 'PollOption__score' },\n\t        pollopt.score,\n\t        ' point',\n\t        pluralise(pollopt.score)\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = PollOption;\n\n/***/ },\n\n/***/ \"sZWe\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar Link = __webpack_require__(\"mEw0\");\n\tvar TimeAgo = __webpack_require__(\"z3IR\").default;\n\t\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\tvar pluralise = __webpack_require__(\"HSmy\");\n\tvar urlParse = __webpack_require__(\"kIhv\");\n\t\n\tvar parseHost = function parseHost(url) {\n\t  var hostname = urlParse(url, true).hostname;\n\t  var parts = hostname.split('.').slice(-3);\n\t  if (parts[0] === 'www') {\n\t    parts.shift();\n\t  }\n\t  return parts.join('.');\n\t};\n\t\n\t/**\r\n\t * Reusable logic for displaying an item.\r\n\t */\n\tvar ItemMixin = {\n\t  /**\r\n\t   * Render an item's metadata bar.\r\n\t   */\n\t  renderItemMeta: function renderItemMeta(item, extraContent) {\n\t    var itemDate = new Date(item.time * 1000);\n\t\n\t    if (item.type === 'job') {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Item__meta' },\n\t        React.createElement(TimeAgo, { date: itemDate, className: 'Item__time' })\n\t      );\n\t    }\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Item__meta' },\n\t      React.createElement(\n\t        'span',\n\t        { className: 'Item__score' },\n\t        item.score,\n\t        ' point',\n\t        pluralise(item.score)\n\t      ),\n\t      ' ',\n\t      React.createElement(\n\t        'span',\n\t        { className: 'Item__by' },\n\t        'by ',\n\t        React.createElement(\n\t          Link,\n\t          { to: '/user/' + item.by },\n\t          item.by\n\t        )\n\t      ),\n\t      ' ',\n\t      React.createElement(TimeAgo, { date: itemDate, className: 'Item__time' }),\n\t      ' | ',\n\t      React.createElement(\n\t        Link,\n\t        { to: '/' + item.type + '/' + item.id },\n\t        item.descendants > 0 ? item.descendants + ' comment' + pluralise(item.descendants) : 'discuss'\n\t      ),\n\t      extraContent\n\t    );\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Render an item's title bar.\r\n\t   */\n\t  renderItemTitle: function renderItemTitle(item) {\n\t    var hasURL = !!item.url;\n\t    var title;\n\t    if (item.dead) {\n\t      title = '[dead] ' + item.title;\n\t    } else {\n\t      title = hasURL ? React.createElement(\n\t        'a',\n\t        { href: item.url },\n\t        item.title\n\t      ) : React.createElement(\n\t        Link,\n\t        { to: '/' + item.type + '/' + item.id },\n\t        item.title\n\t      );\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Item__title', style: { fontSize: SettingsStore.titleFontSize } },\n\t      title,\n\t      hasURL && ' ',\n\t      hasURL && React.createElement(\n\t        'span',\n\t        { className: 'Item__host' },\n\t        '(',\n\t        parseHost(item.url),\n\t        ')'\n\t      )\n\t    );\n\t  }\n\t};\n\t\n\tmodule.exports = ItemMixin;\n\n/***/ },\n\n/***/ \"SIDF\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(\"FN8c\"),\n\t    SITE_TITLE = _require.SITE_TITLE;\n\t\n\tfunction setTitle(title) {\n\t  if (typeof document === 'undefined') return;\n\t  document.title = title ? title + ' | ' + SITE_TITLE : SITE_TITLE;\n\t}\n\t\n\tmodule.exports = setTitle;\n\n/***/ },\n\n/***/ \"pnOm\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar Link = __webpack_require__(\"mEw0\");\n\t\n\tvar Settings = __webpack_require__(\"sFNP\");\n\t\n\tvar StoryStore = __webpack_require__(\"FA3V\");\n\tvar UpdatesStore = __webpack_require__(\"fsMb\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar App = React.createClass({\n\t  displayName: 'App',\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      showSettings: false,\n\t      showChildren: false,\n\t      prebootHTML: this.props.params.prebootHTML\n\t    };\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    SettingsStore.load();\n\t    StoryStore.loadSession();\n\t    UpdatesStore.loadSession();\n\t    if (typeof window === 'undefined') return;\n\t    window.addEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t  componentDidMount: function componentDidMount() {\n\t    // Empty the prebooted HTML and hydrate using live results from Firebase\n\t    this.setState({ prebootHTML: '', showChildren: true });\n\t  },\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    if (typeof window === 'undefined') return;\n\t    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Give stores a chance to persist data to sessionStorage in case this is a\r\n\t   * refresh or an external link in the same tab.\r\n\t   */\n\t  handleBeforeUnload: function handleBeforeUnload() {\n\t    StoryStore.saveSession();\n\t    UpdatesStore.saveSession();\n\t  },\n\t  toggleSettings: function toggleSettings(e) {\n\t    e.preventDefault();\n\t    this.setState({ showSettings: !this.state.showSettings });\n\t  },\n\t  render: function render() {\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'App', onClick: this.state.showSettings && this.toggleSettings },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'App__wrap' },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'App__header' },\n\t          React.createElement(\n\t            Link,\n\t            { to: '/news', className: 'App__homelinkicon' },\n\t            React.createElement('img', { src: 'img/logo.png', width: '16', height: '16', alt: '' })\n\t          ),\n\t          ' ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/news', activeClassName: 'active', className: 'App__homelink' },\n\t            'React HN'\n\t          ),\n\t          ' ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/newest', activeClassName: 'active' },\n\t            'new'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/newcomments', activeClassName: 'active' },\n\t            'comments'\n\t          ),\n\t          ' ',\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/show', activeClassName: 'active' },\n\t            'show'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/ask', activeClassName: 'active' },\n\t            'ask'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/jobs', activeClassName: 'active' },\n\t            'jobs'\n\t          ),\n\t          React.createElement(\n\t            'a',\n\t            { className: 'App__settings', tabIndex: '0', onClick: this.toggleSettings, onKeyPress: this.toggleSettings },\n\t            this.state.showSettings ? 'hide settings' : 'settings'\n\t          ),\n\t          this.state.showSettings && React.createElement(Settings, { key: 'settings' })\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'App__content' },\n\t          React.createElement('div', { dangerouslySetInnerHTML: { __html: this.state.prebootHTML } }),\n\t          this.state.showChildren ? this.props.children : ''\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'App__footer' },\n\t          React.createElement(\n\t            'a',\n\t            { href: 'https://github.com/insin/react-hn' },\n\t            'insin/react-hn'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = App;\n\n/***/ },\n\n/***/ \"sFNP\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar Settings = React.createClass({\n\t  displayName: 'Settings',\n\t  componentDidMount: function componentDidMount() {\n\t    this.refs.container.focus();\n\t  },\n\t  onChange: function onChange(e) {\n\t    var el = e.target;\n\t    if (el.type === 'checkbox') {\n\t      SettingsStore[el.name] = el.checked;\n\t    } else if (el.type === 'number' && el.value) {\n\t      SettingsStore[el.name] = el.value;\n\t    }\n\t    this.forceUpdate();\n\t    SettingsStore.save();\n\t  },\n\t  onClick: function onClick(e) {\n\t    e.stopPropagation();\n\t  },\n\t  render: function render() {\n\t    return React.createElement(\n\t      'div',\n\t      { ref: 'container', className: 'Settings', tabIndex: '-1', onClick: this.onClick },\n\t      React.createElement(\n\t        'form',\n\t        { onChange: this.onChange },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'autoCollapse' },\n\t            React.createElement('input', { type: 'checkbox', name: 'autoCollapse', id: 'autoCollapse', checked: SettingsStore.autoCollapse }),\n\t            ' auto collapse'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Automatically collapse comment threads without new comments on page load.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'replyLinks' },\n\t            React.createElement('input', { type: 'checkbox', name: 'replyLinks', id: 'replyLinks', checked: SettingsStore.replyLinks }),\n\t            ' show reply links'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Show \"reply\" links to Hacker News'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'offlineMode' },\n\t            React.createElement('input', { type: 'checkbox', name: 'offlineMode', id: 'offlineMode', checked: SettingsStore.offlineMode }),\n\t            ' Offline Mode'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Cache comments and content offline.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'showDead' },\n\t            React.createElement('input', { type: 'checkbox', name: 'showDead', id: 'showDead', checked: SettingsStore.showDead }),\n\t            ' show dead'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Show items flagged as dead.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'showDeleted' },\n\t            React.createElement('input', { type: 'checkbox', name: 'showDeleted', id: 'showDeleted', checked: SettingsStore.showDeleted }),\n\t            ' show deleted'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Show comments flagged as deleted in threads.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting' },\n\t          React.createElement(\n\t            'table',\n\t            null,\n\t            React.createElement(\n\t              'tbody',\n\t              null,\n\t              React.createElement(\n\t                'tr',\n\t                null,\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement(\n\t                    'label',\n\t                    { htmlFor: 'titleFontSize' },\n\t                    'title font size:'\n\t                  )\n\t                ),\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement('input', { type: 'number', min: '13.333', step: '1', name: 'titleFontSize', id: 'titleFontSize', value: SettingsStore.titleFontSize })\n\t                )\n\t              ),\n\t              React.createElement(\n\t                'tr',\n\t                null,\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement(\n\t                    'label',\n\t                    { htmlFor: 'listSpacing' },\n\t                    'list spacing:'\n\t                  )\n\t                ),\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement('input', { type: 'number', min: '0', name: 'listSpacing', id: 'listSpacing', value: SettingsStore.listSpacing })\n\t                )\n\t              )\n\t            )\n\t          )\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Settings;\n\n/***/ },\n\n/***/ \"dApQ\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\tvar StoryStore = __webpack_require__(\"FA3V\");\n\t\n\tvar PageNumberMixin = __webpack_require__(\"eigB\");\n\tvar Paginator = __webpack_require__(\"SE0F\");\n\tvar Spinner = __webpack_require__(\"OieW\");\n\tvar StoryListItem = __webpack_require__(\"ITt7\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar _require = __webpack_require__(\"FN8c\"),\n\t    ITEMS_PER_PAGE = _require.ITEMS_PER_PAGE;\n\t\n\tvar pageCalc = __webpack_require__(\"gah7\");\n\tvar setTitle = __webpack_require__(\"SIDF\");\n\t\n\tvar Stories = React.createClass({\n\t  displayName: 'Stories',\n\t\n\t  mixins: [PageNumberMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      ids: [],\n\t      limit: this.props.limit,\n\t      stories: []\n\t    };\n\t  },\n\t  componentDidMount: function componentDidMount() {\n\t    setTitle(this.props.title);\n\t    this.store = new StoryStore(this.props.type);\n\t    this.store.addListener('update', this.handleUpdate);\n\t    this.store.start();\n\t    this.setState(this.store.getState());\n\t  },\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    this.store.removeListener('update', this.handleUpdate);\n\t    this.store.stop();\n\t    this.store = null;\n\t  },\n\t  handleUpdate: function handleUpdate(update) {\n\t    if (!this.isMounted()) {\n\t      if (false) {\n\t        console.warn('Skipping update as the ' + this.props.type + ' Stories component is no longer mounted.');\n\t      }\n\t      return;\n\t    }\n\t    update.limit = update.ids.length;\n\t    this.setState(update);\n\t  },\n\t  render: function render() {\n\t    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, this.state.limit);\n\t\n\t    // Display a list of placeholder items while we're waiting for the initial\n\t    // list of story ids to load from Firebase.\n\t    if (this.state.stories.length === 0 && this.state.ids.length === 0 && this.getPageNumber() > 0) {\n\t      var dummyItems = [];\n\t      for (var i = page.startIndex; i < page.endIndex; i++) {\n\t        dummyItems.push(React.createElement(\n\t          'li',\n\t          { key: i, className: 'ListItem ListItem--loading', style: { marginBottom: SettingsStore.listSpacing } },\n\t          React.createElement(Spinner, null)\n\t        ));\n\t      }\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Items Items--loading' },\n\t        React.createElement(\n\t          'ol',\n\t          { className: 'Items__list', start: page.startIndex + 1 },\n\t          dummyItems\n\t        ),\n\t        React.createElement(Paginator, { route: this.props.route, page: page.pageNum, hasNext: page.hasNext })\n\t      );\n\t    }\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Items' },\n\t      React.createElement(\n\t        'ol',\n\t        { className: 'Items__list', start: page.startIndex + 1 },\n\t        this.renderItems(page.startIndex, page.endIndex)\n\t      ),\n\t      React.createElement(Paginator, { route: this.props.route, page: page.pageNum, hasNext: page.hasNext })\n\t    );\n\t  },\n\t  renderItems: function renderItems(startIndex, endIndex) {\n\t    var rendered = [];\n\t    for (var i = startIndex; i < endIndex; i++) {\n\t      var item = this.state.stories[i];\n\t      var id = this.state.ids[i];\n\t      if (id) {\n\t        rendered.push(React.createElement(StoryListItem, { key: id, id: id, index: i, cachedItem: item, store: this.store }));\n\t      } else {\n\t        rendered.push(React.createElement(StoryListItem, { cachedItem: item, store: this.store }));\n\t      }\n\t    }\n\t    return rendered;\n\t  }\n\t});\n\t\n\tmodule.exports = Stories;\n\n/***/ },\n\n/***/ \"eigB\":\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar PageNumberMixin = {\n\t  getPageNumber: function getPageNumber(page) {\n\t    if (typeof page == 'undefined') {\n\t      page = this.props.location.query.page;\n\t    }\n\t    return page && /^\\d+$/.test(page) ? Math.max(1, Number(page)) : 1;\n\t  }\n\t};\n\t\n\tmodule.exports = PageNumberMixin;\n\n/***/ },\n\n/***/ \"SE0F\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar Link = __webpack_require__(\"mEw0\");\n\t\n\tvar Paginator = React.createClass({\n\t  displayName: 'Paginator',\n\t  _onClick: function _onClick(e) {\n\t    setTimeout(function () {\n\t      window.scrollTo(0, 0);\n\t    }, 0);\n\t  },\n\t  render: function render() {\n\t    if (this.props.page === 1 && !this.props.hasNext) {\n\t      return null;\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Paginator' },\n\t      this.props.page > 1 && React.createElement(\n\t        'span',\n\t        { className: 'Paginator__prev' },\n\t        React.createElement(\n\t          Link,\n\t          { to: { pathname: '/' + this.props.route, query: { page: this.props.page - 1 } }, onClick: this._onClick },\n\t          'Prev'\n\t        )\n\t      ),\n\t      this.props.page > 1 && this.props.hasNext && ' | ',\n\t      this.props.hasNext && React.createElement(\n\t        'span',\n\t        { className: 'Paginator__next' },\n\t        React.createElement(\n\t          Link,\n\t          { to: { pathname: '/' + this.props.route, query: { page: this.props.page + 1 } }, onClick: this._onClick },\n\t          'More'\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Paginator;\n\n/***/ },\n\n/***/ \"ITt7\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar ReactFireMixin = __webpack_require__(\"ZZqC\");\n\t\n\tvar StoryCommentThreadStore = __webpack_require__(\"PJIF\");\n\tvar HNService = __webpack_require__(\"VIGu\");\n\tvar HNServiceRest = __webpack_require__(\"uaYK\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\tvar StoryStore = __webpack_require__(\"FA3V\");\n\t\n\tvar ItemMixin = __webpack_require__(\"sZWe\");\n\tvar ListItemMixin = __webpack_require__(\"J1hE\");\n\tvar Spinner = __webpack_require__(\"OieW\");\n\t\n\t/**\r\n\t * Display story title and metadata as as a list item.\r\n\t * Cached story data may be given as a prop, but this component is also\r\n\t * responsible for listening to updates to the story and providing the latest\r\n\t * version for StoryStore's cache.\r\n\t */\n\tvar StoryListItem = React.createClass({\n\t  displayName: 'StoryListItem',\n\t\n\t  mixins: [ItemMixin, ListItemMixin, ReactFireMixin],\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      id: null,\n\t      cachedItem: null,\n\t      index: null\n\t    };\n\t  },\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      item: this.props.cachedItem || {}\n\t    };\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    if (this.props.id != null) {\n\t      this.initLiveItem(this.props);\n\t    } else if (this.props.cachedItem != null) {\n\t      // Display the comment state of the cached item we were given while we're\n\t      // waiting for the live item to load.\n\t      this.threadState = StoryCommentThreadStore.loadState(this.state.item.id);\n\t    }\n\t  },\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    if (this.props.id != null) {\n\t      this.props.store.removeListener(this.props.id, this.updateThreadState);\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Catch the transition from not having an id prop to having one.\r\n\t   * Scenario: we were waiting for the initial list of story ids to load.\r\n\t   */\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.id == null && nextProps.id != null) {\n\t      this.initLiveItem(nextProps);\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * If the live item has been loaded or updated, update the StoryStore cache\r\n\t   * with its current index and latest data.\r\n\t   */\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    if (this.state.item !== nextState.item) {\n\t      if (nextState.item != null) {\n\t        this.props.store.itemUpdated(nextState.item, this.props.index);\n\t      } else {\n\t        if (false) {\n\t          console.warn('Item ' + this.props.id + ' went from ' + JSON.stringify(this.state.item) + ' to ' + nextProps.item);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Initialise listening to updates for the item with the given id and\r\n\t   * initialise its comment thread state.\r\n\t   */\n\t  initLiveItem: function initLiveItem(props) {\n\t    if (SettingsStore.offlineMode) {\n\t      HNServiceRest.itemRef(props.id).then(function (res) {\n\t        return res.json();\n\t      }).then(function (snapshot) {\n\t        this.replaceState({ item: snapshot });\n\t      }.bind(this));\n\t    } else {\n\t      // If we were given a cached item to display initially, it will be replaced\n\t      this.bindAsObject(HNService.itemRef(props.id), 'item');\n\t    }\n\t\n\t    this.threadState = StoryCommentThreadStore.loadState(props.id);\n\t    this.props.store.addListener(props.id, this.updateThreadState);\n\t  },\n\t\n\t\n\t  /**\r\n\t   * Update thread state in response to a storage event indicating it has been\r\n\t   * modified.\r\n\t   */\n\t  updateThreadState: function updateThreadState() {\n\t    this.threadState = StoryCommentThreadStore.loadState(this.props.id);\n\t    this.forceUpdate();\n\t  },\n\t  render: function render() {\n\t    // Display the loading spinner if we have nothing to show initially\n\t    if (!this.state.item || !this.state.item.id) {\n\t      return React.createElement(\n\t        'li',\n\t        { className: 'ListItem ListItem--loading', style: { marginBottom: SettingsStore.listSpacing } },\n\t        React.createElement(Spinner, null)\n\t      );\n\t    }\n\t\n\t    return this.renderListItem(this.state.item, this.threadState);\n\t  }\n\t});\n\t\n\tmodule.exports = StoryListItem;\n\n/***/ },\n\n/***/ \"J1hE\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar Link = __webpack_require__(\"mEw0\");\n\t\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\tvar cx = __webpack_require__(\"H9Jo\");\n\t\n\t/**\r\n\t * Reusable logic for displaying an item in a list.\r\n\t * Must be used in conjunction with ItemMixin for its rendering methods.\r\n\t */\n\tvar ListItemMixin = {\n\t  getNewCommentCount: function getNewCommentCount(item, threadState) {\n\t    if (threadState.lastVisit === null) {\n\t      return 0;\n\t    }\n\t    return item.descendants - threadState.commentCount;\n\t  },\n\t  renderListItem: function renderListItem(item, threadState) {\n\t    if (item.deleted) {\n\t      return null;\n\t    }\n\t    var newCommentCount = this.getNewCommentCount(item, threadState);\n\t    return React.createElement(\n\t      'li',\n\t      { className: cx('ListItem', { 'ListItem--dead': item.dead }), style: { marginBottom: SettingsStore.listSpacing } },\n\t      this.renderItemTitle(item),\n\t      this.renderItemMeta(item, newCommentCount > 0 && React.createElement(\n\t        'span',\n\t        { className: 'ListItem__newcomments' },\n\t        ' ',\n\t        '(',\n\t        React.createElement(\n\t          Link,\n\t          { to: '/' + item.type + '/' + item.id },\n\t          newCommentCount,\n\t          ' new'\n\t        ),\n\t        ')'\n\t      ))\n\t    );\n\t  }\n\t};\n\t\n\tmodule.exports = ListItemMixin;\n\n/***/ },\n\n/***/ \"gah7\":\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction pageCalc(pageNum, pageSize, numItems) {\n\t  var startIndex = (pageNum - 1) * pageSize;\n\t  var endIndex = Math.min(numItems, startIndex + pageSize);\n\t  var hasNext = endIndex < numItems - 1;\n\t  return { pageNum: pageNum, startIndex: startIndex, endIndex: endIndex, hasNext: hasNext };\n\t}\n\t\n\tmodule.exports = pageCalc;\n\n/***/ },\n\n/***/ \"S+0w\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\tvar UpdatesStore = __webpack_require__(\"fsMb\");\n\t\n\tvar DisplayListItem = __webpack_require__(\"USDx\");\n\tvar DisplayComment = __webpack_require__(\"VThE\");\n\tvar Paginator = __webpack_require__(\"SE0F\");\n\tvar Spinner = __webpack_require__(\"OieW\");\n\t\n\tvar PageNumberMixin = __webpack_require__(\"eigB\");\n\t\n\tvar _require = __webpack_require__(\"FN8c\"),\n\t    ITEMS_PER_PAGE = _require.ITEMS_PER_PAGE;\n\t\n\tvar pageCalc = __webpack_require__(\"gah7\");\n\tvar _setTitle = __webpack_require__(\"SIDF\");\n\t\n\tfunction filterDead(item) {\n\t  return !item.dead;\n\t}\n\t\n\tfunction filterUpdates(updates) {\n\t  if (!SettingsStore.showDead) {\n\t    return {\n\t      comments: updates.comments.filter(filterDead),\n\t      stories: updates.stories.filter(filterDead)\n\t    };\n\t  }\n\t  return updates;\n\t}\n\t\n\tvar Updates = React.createClass({\n\t  displayName: 'Updates',\n\t\n\t  mixins: [PageNumberMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return filterUpdates(UpdatesStore.getUpdates());\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    this.setTitle(this.props.type);\n\t    UpdatesStore.start();\n\t    UpdatesStore.on('updates', this.handleUpdates);\n\t  },\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    UpdatesStore.off('updates', this.handleUpdates);\n\t    UpdatesStore.stop();\n\t  },\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.type !== nextProps.type) {\n\t      this.setTitle(nextProps.type);\n\t    }\n\t  },\n\t  setTitle: function setTitle(type) {\n\t    _setTitle('New ' + (type === 'comments' ? 'Comments' : 'Links'));\n\t  },\n\t  handleUpdates: function handleUpdates(updates) {\n\t    if (!this.isMounted()) {\n\t      if (false) {\n\t        console.warn('Skipping update of ' + this.props.type + ' as the Updates component is not mounted');\n\t      }\n\t      return;\n\t    }\n\t    this.setState(filterUpdates(updates));\n\t  },\n\t  render: function render() {\n\t    var items = this.props.type === 'comments' ? this.state.comments : this.state.stories;\n\t    if (items.length === 0) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Updates Updates--loading' },\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t\n\t    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, items.length);\n\t\n\t    if (this.props.type === 'comments') {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Updates Comments' },\n\t        items.slice(page.startIndex, page.endIndex).map(function (comment) {\n\t          return React.createElement(DisplayComment, { key: comment.id, id: comment.id, comment: comment });\n\t        }),\n\t        React.createElement(Paginator, { route: 'newcomments', page: page.pageNum, hasNext: page.hasNext })\n\t      );\n\t    } else {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Updates Items' },\n\t        React.createElement(\n\t          'ol',\n\t          { className: 'Items__list', start: page.startIndex + 1 },\n\t          items.slice(page.startIndex, page.endIndex).map(function (item) {\n\t            return React.createElement(DisplayListItem, { key: item.id, item: item });\n\t          })\n\t        ),\n\t        React.createElement(Paginator, { route: 'newest', page: page.pageNum, hasNext: page.hasNext })\n\t      );\n\t    }\n\t  }\n\t});\n\t\n\tmodule.exports = Updates;\n\n/***/ },\n\n/***/ \"USDx\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\t\n\tvar StoryCommentThreadStore = __webpack_require__(\"PJIF\");\n\t\n\tvar ItemMixin = __webpack_require__(\"sZWe\");\n\tvar ListItemMixin = __webpack_require__(\"J1hE\");\n\t\n\t/**\r\n\t * Display story title and metadata as a list item.\r\n\t * The story to display will be passed as a prop.\r\n\t */\n\tvar DisplayListItem = React.createClass({\n\t  displayName: 'DisplayListItem',\n\t\n\t  mixins: [ItemMixin, ListItemMixin],\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.threadState = StoryCommentThreadStore.loadState(this.props.item.id);\n\t  },\n\t  render: function render() {\n\t    return this.renderListItem(this.props.item, this.threadState);\n\t  }\n\t});\n\t\n\tmodule.exports = DisplayListItem;\n\n/***/ },\n\n/***/ \"4fZb\":\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(\"uMu9\");\n\tvar ReactFireMixin = __webpack_require__(\"ZZqC\");\n\t\n\tvar CommentThreadStore = __webpack_require__(\"Hwo6\");\n\tvar HNService = __webpack_require__(\"VIGu\");\n\tvar HNServiceRest = __webpack_require__(\"uaYK\");\n\tvar SettingsStore = __webpack_require__(\"NPdQ\");\n\t\n\tvar CommentMixin = __webpack_require__(\"bFfS\");\n\t\n\tvar cx = __webpack_require__(\"H9Jo\");\n\t\n\t/**\r\n\t * A comment in a thread.\r\n\t */\n\tvar Comment = React.createClass({\n\t  displayName: 'Comment',\n\t\n\t  mixins: [CommentMixin, ReactFireMixin],\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      loadingSpinner: false\n\t    };\n\t  },\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      comment: {}\n\t    };\n\t  },\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindFirebaseRef();\n\t  },\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    this.clearDelayTimeout();\n\t  },\n\t  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t    // Huge, fast-growing threads like https://news.ycombinator.com/item?id=9784470\n\t    // seem to break the API - some comments are coming back from Firebase as null.\n\t    if (!this.state.comment) {\n\t      this.props.threadStore.adjustExpectedComments(-1);\n\t      return;\n\t    }\n\t\n\t    // On !prevState.comment: a comment which was initially null - see\n\t    // above - may eventually load when the API catches up.\n\t    if (!prevState.comment || !prevState.comment.id) {\n\t      // Register a newly-loaded comment with the thread store\n\t      if (this.state.comment.id) {\n\t        // If the comment was delayed, cancel any pending timeout\n\t        if (prevState.comment && prevState.comment.delayed) {\n\t          this.clearDelayTimeout();\n\t        }\n\t        this.props.threadStore.commentAdded(this.state.comment);\n\t      }\n\t      if (prevState.comment && !prevState.comment.delayed && this.state.comment.delayed) {\n\t        this.props.threadStore.commentDelayed(this.props.id);\n\t      }\n\t    }\n\t    // The comment was already loaded, look for changes to it\n\t    else {\n\t        if (!prevState.comment.deleted && this.state.comment.deleted) {\n\t          this.props.threadStore.commentDeleted(this.state.comment);\n\t        }\n\t        if (!prevState.comment.dead && this.state.comment.dead) {\n\t          this.props.threadStore.commentDied(this.state.comment);\n\t        }\n\t        // If the comment has been updated and the initial set of comments is\n\t        // still loading, the number of expected comments might need to be\n\t        // adjusted.\n\t        else if (prevState.comment !== this.state.comment && this.props.threadStore.loading) {\n\t            var kids = this.state.comment.kids ? this.state.comment.kids.length : 0;\n\t            var prevKids = prevState.comment.kids ? prevState.comment.kids.length : 0;\n\t            this.props.threadStore.adjustExpectedComments(kids - prevKids);\n\t          }\n\t      }\n\t  },\n\t  bindFirebaseRef: function bindFirebaseRef() {\n\t    if (SettingsStore.offlineMode) {\n\t      HNServiceRest.itemRef(this.props.id).then(function (res) {\n\t        return res.json();\n\t      }).then(function (snapshot) {\n\t        this.replaceState({ comment: snapshot });\n\t      }.bind(this));\n\t    } else {\n\t      this.bindAsObject(HNService.itemRef(this.props.id), 'comment', this.handleFirebaseRefCancelled);\n\t    }\n\t\n\t    if (this.timeout) {\n\t      this.timeout = null;\n\t    }\n\t  },\n\t\n\t\n\t  /**\r\n\t   * This is usually caused by a permissions error loading the comment due to\r\n\t   * its author using the delay setting (note: this is conjecture), which is\r\n\t   * measured in minutes - try again in 30 seconds.\r\n\t   */\n\t  handleFirebaseRefCancelled: function handleFirebaseRefCancelled(e) {\n\t    if (false) {\n\t      console.error('Firebase ref for comment ' + this.props.id + ' was cancelled: ' + e.message);\n\t    }\n\t    this.unbind('comment');\n\t    this.timeout = setTimeout(this.bindFirebaseRef, 30000);\n\t    if (this.state.comment && !this.state.comment.delayed) {\n\t      this.state.comment.delayed = true;\n\t      this.forceUpdate();\n\t    }\n\t  },\n\t  clearDelayTimeout: function clearDelayTimeout() {\n\t    if (this.timeout) {\n\t      clearTimeout(this.timeout);\n\t      this.timeout = null;\n\t    }\n\t  },\n\t  toggleCollapse: function toggleCollapse(e) {\n\t    e.preventDefault();\n\t    this.props.threadStore.toggleCollapse(this.state.comment.id);\n\t  },\n\t  render: function render() {\n\t    var comment = this.state.comment;\n\t    var props = this.props;\n\t    if (!comment) {\n\t      return this.renderError(comment, {\n\t        id: this.props.id,\n\t        className: 'Comment Comment--error Comment--level' + props.level\n\t      });\n\t    }\n\t    // Render a placeholder while we're waiting for the comment to load\n\t    if (!comment.id) {\n\t      return this.renderCommentLoading(comment);\n\t    }\n\t    // Don't show dead coments or their children, when configured\n\t    if (comment.dead && !SettingsStore.showDead) {\n\t      return null;\n\t    }\n\t    // Render a link to HN for deleted comments if they're being displayed\n\t    if (comment.deleted) {\n\t      if (!SettingsStore.showDeleted) {\n\t        return null;\n\t      }\n\t      return this.renderCommentDeleted(comment, {\n\t        className: 'Comment Comment--deleted Comment--level' + props.level\n\t      });\n\t    }\n\t\n\t    var isNew = props.threadStore.isNew[comment.id];\n\t    var collapsed = !!props.threadStore.isCollapsed[comment.id];\n\t    var childCounts = collapsed && props.threadStore.getChildCounts(comment);\n\t    if (collapsed && isNew) {\n\t      childCounts.newComments = 0;\n\t    }\n\t    var className = cx('Comment Comment--level' + props.level, {\n\t      'Comment--collapsed': collapsed,\n\t      'Comment--dead': comment.dead,\n\t      'Comment--new': isNew\n\t    });\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        this.renderCommentMeta(comment, {\n\t          collapsible: true,\n\t          collapsed: collapsed,\n\t          link: true,\n\t          childCounts: childCounts\n\t        }),\n\t        this.renderCommentText(comment, { replyLink: true })\n\t      ),\n\t      comment.kids && React.createElement(\n\t        'div',\n\t        { className: 'Comment__kids' },\n\t        comment.kids.map(function (id) {\n\t          return React.createElement(Comment, { key: id, id: id,\n\t            level: props.level + 1,\n\t            loadingSpinner: props.loadingSpinner,\n\t            threadStore: props.threadStore\n\t          });\n\t        })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Comment;\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** app.215b85fb.js\n **/","require('setimmediate')\r\n\r\nvar React = require('react')\r\nvar {render} = require('react-dom')\r\nvar Router = require('react-router/lib/Router')\r\nvar createHashHistory = require('history/lib/createHashHistory')\r\nvar useScroll = require('react-router-scroll/lib/useScroll')\r\nvar applyRouterMiddleware = require('react-router/lib/applyRouterMiddleware')\r\nvar history = createHashHistory()\r\n\r\nvar routes = require('./routes')\r\n\r\nrender(<Router history={history} render={applyRouterMiddleware(useScroll())} routes={routes}/>, document.getElementById('app'))\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","var IndexRoute = require('react-router/lib/IndexRoute')\r\nvar React = require('react')\r\nvar Route = require('react-router/lib/Route')\r\nvar Item = require('./Item')\r\n// Polyfill require.ensure\r\nif (typeof require.ensure !== 'function') require.ensure = function(d, c) { c(require) }\r\n\r\nvar App = require('./App')\r\nvar Stories = require('./Stories')\r\nvar Updates = require('./Updates')\r\n\r\nfunction stories(route, type, limit, title) {\r\n  return React.createClass({\r\n    render() {\r\n      return <Stories {...this.props} key={route} route={route} type={type} limit={limit} title={title}/>\r\n    }\r\n  })\r\n}\r\n\r\nfunction updates(type) {\r\n  return React.createClass({\r\n    render() {\r\n      return <Updates {...this.props} key={type} type={type}/>\r\n    }\r\n  })\r\n}\r\n\r\nvar Ask = stories('ask', 'askstories', 200, 'Ask')\r\nvar Comments = updates('comments')\r\nvar Jobs = stories('jobs', 'jobstories', 200, 'Jobs')\r\nvar New = stories('newest', 'newstories', 500, 'New Links')\r\nvar Show = stories('show', 'showstories', 200, 'Show')\r\nvar Top = stories('news', 'topstories', 500)\r\n\r\nmodule.exports = <Route path=\"/\" component={App}>\r\n  <IndexRoute component={Top}/>\r\n  <Route path=\"news\" component={Top}/>\r\n  <Route path=\"newest\" component={New}/>\r\n  <Route path=\"show\" component={Show}/>\r\n  <Route path=\"ask\" component={Ask}/>\r\n  <Route path=\"jobs\" component={Jobs}/>\r\n  <Route path=\"item/:id\" component={Item}/>\r\n  <Route path=\"job/:id\" component={Item}/>\r\n  <Route path=\"poll/:id\" component={Item}/>\r\n  <Route path=\"story/:id\" component={Item}/>\r\n  <Route\r\n    path=\"comment/:id\"\r\n    getComponent={(location, callback) => {\r\n      require.ensure([], require => {\r\n        callback(null, require('./PermalinkedComment'))\r\n      }, 'PermalinkedComment')\r\n    }}\r\n  />\r\n  <Route path=\"newcomments\" component={Comments}/>\r\n  <Route\r\n    path=\"user/:id\"\r\n    getComponent={(location, callback) => {\r\n      require.ensure([], require => {\r\n        callback(null, require('./UserProfile'))\r\n      }, 'UserProfile')\r\n    }}\r\n  />\r\n  <Route\r\n    path=\"*\"\r\n    getComponent={(location, callback) => {\r\n      require.ensure([], require => {\r\n        callback(null, require('./NotFound'))\r\n      }, 'NotFound')\r\n    }}\r\n  />\r\n</Route>\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/routes.js\n **/","var React = require('react')\r\nvar ReactFireMixin = require('reactfire')\r\nvar TimeAgo = require('react-timeago').default\r\n\r\nvar HNService = require('./services/HNService')\r\nvar HNServiceRest = require('./services/HNServiceRest')\r\nvar StoryCommentThreadStore = require('./stores/StoryCommentThreadStore')\r\nvar ItemStore = require('./stores/ItemStore')\r\n\r\nvar Comment = require('./Comment')\r\nvar PollOption = require('./PollOption')\r\nvar Spinner = require('./Spinner')\r\nvar ItemMixin = require('./mixins/ItemMixin')\r\n\r\nvar cx = require('./utils/buildClassName')\r\nvar setTitle = require('./utils/setTitle')\r\n\r\nvar SettingsStore = require('./stores/SettingsStore')\r\n\r\nfunction timeUnitsAgo(value, unit, suffix) {\r\n  if (value === 1) {\r\n    return unit\r\n  }\r\n  return `${value} ${unit}s`\r\n}\r\n\r\nvar Item = React.createClass({\r\n  mixins: [ItemMixin, ReactFireMixin],\r\n\r\n  getInitialState() {\r\n    return {\r\n      item: ItemStore.getCachedStory(Number(this.props.params.id)) || {}\r\n    }\r\n  },\r\n\r\n  componentWillMount() {\r\n    if (SettingsStore.offlineMode) {\r\n      HNServiceRest.itemRef(this.props.params.id).then(function(res) {\r\n        return res.json()\r\n      }).then(function(snapshot) {\r\n        this.replaceState({ item: snapshot })\r\n      }.bind(this))\r\n    }\r\n    else {\r\n      this.bindAsObject(HNService.itemRef(this.props.params.id), 'item')\r\n    }\r\n\r\n    if (this.state.item.id) {\r\n      this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, {cached: true})\r\n      setTitle(this.state.item.title)\r\n    }\r\n    window.addEventListener('beforeunload', this.handleBeforeUnload)\r\n  },\r\n\r\n  componentWillUnmount() {\r\n    if (this.threadStore) {\r\n      this.threadStore.dispose()\r\n    }\r\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\r\n  },\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (this.props.params.id !== nextProps.params.id) {\r\n      // Tear it down...\r\n      this.threadStore.dispose()\r\n      this.threadStore = null\r\n      this.unbind('item')\r\n      // ...and set it up again\r\n      var item = ItemStore.getCachedStory(Number(nextProps.params.id))\r\n      if (item) {\r\n        this.threadStore = new StoryCommentThreadStore(item, this.handleCommentsChanged, {cached: true})\r\n        setTitle(item.title)\r\n      }\r\n\r\n      if (SettingsStore.offlineMode) {\r\n        HNServiceRest.itemRef(nextProps.params.id).then(function(res) {\r\n          return res.json()\r\n        }).then(function(snapshot) {\r\n          this.replaceState({ item: snapshot })\r\n        }.bind(this))\r\n      }\r\n      else {\r\n        this.bindAsObject(HNService.itemRef(nextProps.params.id), 'item')\r\n        this.setState({item: item || {}})\r\n      }\r\n    }\r\n  },\r\n\r\n  componentWillUpdate(nextProps, nextState) {\r\n    // Update the title when the item has loaded.\r\n    if (!this.state.item.id && nextState.item.id) {\r\n      setTitle(nextState.item.title)\r\n    }\r\n  },\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    // If the state item id changed, an initial or new item must have loaded\r\n    if (prevState.item.id !== this.state.item.id) {\r\n      if (!this.threadStore || this.threadStore.itemId !== this.state.item.id) {\r\n        this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, {cached: false})\r\n        setTitle(this.state.item.title)\r\n        this.forceUpdate()\r\n      }\r\n    }\r\n    else if (prevState.item !== this.state.item) {\r\n      // If the item has been updated from Firebase and the initial set\r\n      // of comments is still loading, the number of expected comments might\r\n      // need to be adjusted.\r\n      // This triggers a check for thread load completion, completing it\r\n      // immediately if a cached item had 0 kids and the latest version from\r\n      // Firebase also has 0 kids.\r\n      if (this.threadStore.loading) {\r\n        var kids = (this.state.item.kids ? this.state.item.kids.length : 0)\r\n        var prevKids = (prevState.item.kids ? prevState.item.kids.length : 0)\r\n        var kidDiff = kids - prevKids\r\n        if (kidDiff !== 0) {\r\n          this.threadStore.adjustExpectedComments(kidDiff)\r\n        }\r\n      }\r\n      this.threadStore.itemUpdated(this.state.item)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Ensure the last visit time and comment details get stored for this item if\r\n   * the user refreshes or otherwise navigates off the page.\r\n   */\r\n  handleBeforeUnload() {\r\n    if (this.threadStore) {\r\n      this.threadStore.dispose()\r\n    }\r\n  },\r\n\r\n  handleCommentsChanged(payload) {\r\n    this.forceUpdate()\r\n  },\r\n\r\n  autoCollapse(e) {\r\n    e.preventDefault()\r\n    this.threadStore.collapseThreadsWithoutNewComments()\r\n  },\r\n\r\n  markAsRead(e) {\r\n    e.preventDefault()\r\n    this.threadStore.markAsRead()\r\n    this.forceUpdate()\r\n  },\r\n\r\n  render() {\r\n    var state = this.state\r\n    var item = state.item\r\n    var threadStore = this.threadStore\r\n    if (!item.id || !threadStore) { return <div className=\"Item Item--loading\"><Spinner size=\"20\"/></div> }\r\n    return <div className={cx('Item', {'Item--dead': item.dead})}>\r\n      <div className=\"Item__content\">\r\n        {this.renderItemTitle(item)}\r\n        {this.renderItemMeta(item, (threadStore.lastVisit !== null && threadStore.newCommentCount > 0 && <span>{' '}\r\n          (<em>{threadStore.newCommentCount} new</em> in the last <TimeAgo date={threadStore.lastVisit} formatter={timeUnitsAgo}/>{') | '}\r\n          <span className=\"control\" tabIndex=\"0\" onClick={this.autoCollapse} onKeyPress={this.autoCollapse} title=\"Collapse threads without new comments\">\r\n            auto collapse\r\n          </span>{' | '}\r\n          <span className=\"control\" tabIndex=\"0\" onClick={this.markAsRead} onKeyPress={this.markAsRead}>\r\n            mark as read\r\n          </span>\r\n        </span>))}\r\n        {item.text && <div className=\"Item__text\">\r\n          <div dangerouslySetInnerHTML={{__html: item.text}}/>\r\n        </div>}\r\n        {item.type === 'poll' && <div className=\"Item__poll\">\r\n          {item.parts.map(function(id) {\r\n            return <PollOption key={id} id={id}/>\r\n          })}\r\n        </div>}\r\n      </div>\r\n      {item.kids && <div className=\"Item__kids\">\r\n        {item.kids.map(function(id, index) {\r\n          return <Comment key={id} id={id} level={0}\r\n            loadingSpinner={index === 0}\r\n            threadStore={threadStore}\r\n          />\r\n        })}\r\n      </div>}\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = Item\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Item.js\n **/","var firebase = require('firebase/app')\r\nrequire('firebase/database')\r\n\r\nvar config = {\r\n  databaseURL: 'https://hacker-news.firebaseio.com'\r\n}\r\nfirebase.initializeApp(config)\r\nvar version = '/v0'\r\nvar api = firebase.database().ref(version)\r\n\r\n// https://firebase.google.com/support/guides/firebase-web\r\n\r\nfunction fetchItem(id, cb) {\r\n  itemRef(id).once('value', function(snapshot) {\r\n    cb(snapshot.val())\r\n  })\r\n}\r\n\r\nfunction fetchItems(ids, cb) {\r\n  var items = []\r\n  ids.forEach(function(id) {\r\n    fetchItem(id, addItem)\r\n  })\r\n  function addItem(item) {\r\n    items.push(item)\r\n    if (items.length >= ids.length) {\r\n      cb(items)\r\n    }\r\n  }\r\n}\r\n\r\nfunction storiesRef(path) {\r\n  return api.child(path)\r\n}\r\n\r\nfunction itemRef(id) {\r\n  return api.child('item/' + id)\r\n}\r\n\r\nfunction userRef(id) {\r\n  return api.child('user/' + id)\r\n}\r\n\r\nfunction updatesRef() {\r\n  return api.child('updates/items')\r\n}\r\n\r\nmodule.exports = {\r\n  fetchItem,\r\n  fetchItems,\r\n  storiesRef,\r\n  itemRef,\r\n  userRef,\r\n  updatesRef\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/HNService.js\n **/","/* global fetch */\r\nrequire('isomorphic-fetch')\r\n/*\r\nA version of HNService which concumes the Firebase REST\r\nendpoint (https://www.firebase.com/docs/rest/api/). This\r\nis used when a user has enabled 'Offline Mode' in the\r\nSettings panel and ensures responses can be easily fetched\r\nand cached when paired with Service Worker. This cannot be\r\ntrivially done using just Web Sockets with the default\r\nFirebase API and provides a sufficient fallback that works.\r\n */\r\nvar endPoint = 'https://hacker-news.firebaseio.com/v0'\r\nvar options = {\r\n  method: 'GET',\r\n  headers: {\r\n    'Accept': 'application/json'\r\n  }\r\n}\r\n\r\nfunction storiesRef(path) {\r\n  return fetch(endPoint + '/' + path + '.json', options)\r\n}\r\n\r\nfunction itemRef(id) {\r\n  return fetch(endPoint + '/item/' + id + '.json', options)\r\n}\r\n\r\nfunction itemRefJSON(id) {\r\n  return itemRef(id).then(function(response) {\r\n    return response.json()\r\n  })\r\n}\r\n\r\nfunction userRef(id) {\r\n  return fetch(endPoint + '/user/' + id + '.json', options)\r\n}\r\n\r\nfunction updatesRef() {\r\n  return fetch(endPoint + '/updates/items/' + '.json', options)\r\n}\r\n\r\nfunction fetchItem(id, cb) {\r\n  itemRef(id).then(function(snapshot) {\r\n    cb(snapshot)\r\n  })\r\n}\r\n\r\nfunction fetchItems(ids, cb) {\r\n  var items = []\r\n  var promises = []\r\n  ids.forEach(function(id) {\r\n    promises.push(itemRefJSON(id))\r\n  })\r\n  Promise.all(promises).then(function(values) {\r\n    items = values\r\n    if (items.length >= ids.length) {\r\n      cb(items)\r\n    }\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  fetchItem,\r\n  fetchItems,\r\n  storiesRef,\r\n  itemRef,\r\n  userRef,\r\n  updatesRef\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/services/HNServiceRest.js\n **/","var CommentThreadStore = require('./CommentThreadStore')\r\nvar SettingsStore = require('./SettingsStore')\r\n\r\nvar debounce = require('../utils/cancellableDebounce')\r\nvar extend = require('../utils/extend')\r\nvar pluralise = require('../utils/pluralise')\r\nvar storage = require('../utils/storage')\r\n\r\n/**\r\n * Load persisted comment thread state.\r\n * @return .lastVisit {Date} null if the item hasn't been visited before.\r\n * @return .commentCount {Number} 0 if the item hasn't been visited before.\r\n * @return .maxCommentId {Number} 0 if the item hasn't been visited before.\r\n */\r\nfunction loadState(itemId) {\r\n  var json = storage.get(itemId)\r\n  if (json) {\r\n    return JSON.parse(json)\r\n  }\r\n  return {\r\n    lastVisit: null,\r\n    commentCount: 0,\r\n    maxCommentId: 0\r\n  }\r\n}\r\n\r\nfunction StoryCommentThreadStore(item, onCommentsChanged, options) {\r\n  CommentThreadStore.call(this, item, onCommentsChanged)\r\n  this.startedLoading = Date.now()\r\n\r\n  /** Lookup from a comment id to its parent comment id. */\r\n  this.parents = {}\r\n  /** The number of comments which have loaded. */\r\n  this.commentCount = 0\r\n  /** The number of new comments which have loaded. */\r\n  this.newCommentCount = 0\r\n  /** The max comment id seen by the store. */\r\n  this.maxCommentId = 0\r\n  /** Has the comment thread finished loading? */\r\n  this.loading = true\r\n  /** The number of comments we're expecting to load. */\r\n  this.expectedComments = item.kids ? item.kids.length : 0\r\n  /**\r\n   * The number of descendants the story has according to the API.\r\n   * This count includes deleted comments, which aren't accessible via the API,\r\n   * so a thread with deleted comments (example story id: 9273709) will never\r\n   * load this number of comments\r\n   * However, we still need to persist the last known descendant count in order\r\n   * to determine how many new comments there are when displaying the story on a\r\n   * list page.\r\n   */\r\n  this.itemDescendantCount = item.descendants\r\n\r\n  var initialState = loadState(item.id)\r\n  /** Time of last visit to the story. */\r\n  this.lastVisit = initialState.lastVisit\r\n  /** Max comment id on the last visit - determines which comments are new. */\r\n  this.prevMaxCommentId = initialState.maxCommentId\r\n  /** Is this the user's first time viewing the story? */\r\n  this.isFirstVisit = (initialState.lastVisit === null)\r\n\r\n  // Trigger an immediate check for thread load completion if the item was not\r\n  // retrieved from the cache, so is the latest version. This completes page\r\n  // loading immediately for items which have no comments yet.\r\n  if (!options.cached) {\r\n    this.checkLoadCompletion()\r\n  }\r\n}\r\n\r\nStoryCommentThreadStore.loadState = loadState\r\n\r\nStoryCommentThreadStore.prototype = extend(Object.create(CommentThreadStore.prototype), {\r\n  constructor: StoryCommentThreadStore,\r\n\r\n  /**\r\n   * Callback to the item component with updated comment counts, debounced as\r\n   * comments will be loading frequently on initial load.\r\n   */\r\n  numberOfCommentsChanged: debounce(function() {\r\n    this.onCommentsChanged({type: 'number'})\r\n  }, 123),\r\n\r\n  /**\r\n   * If we don't have a last visit time stored for an item, it must have been\r\n   * visited for the first time. Once it finishes loading, establish the last\r\n   * visit time and max comment id which will be used to track and display new\r\n   * comments.\r\n   */\r\n  firstLoadComplete() {\r\n    this.lastVisit = Date.now()\r\n    this.prevMaxCommentId = this.maxCommentId\r\n    this.isFirstVisit = false\r\n    this.onCommentsChanged({type: 'first_load_complete'})\r\n  },\r\n\r\n  /**\r\n   * Check whether the number of comments has reached the expected number yet.\r\n   */\r\n  checkLoadCompletion() {\r\n    if (this.loading && this.commentCount >= this.expectedComments) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.info(\r\n          'Initial load of ' +\r\n           this.commentCount + ' comment' + pluralise(this.commentCount) +\r\n          ' for ' + this.itemId + ' took ' +\r\n          ((Date.now() - this.startedLoading) / 1000).toFixed(2) + 's'\r\n        )\r\n      }\r\n      this.loading = false\r\n      if (this.isFirstVisit) {\r\n        this.firstLoadComplete()\r\n      }\r\n      else if (SettingsStore.autoCollapse && this.newCommentCount > 0) {\r\n        this.collapseThreadsWithoutNewComments()\r\n      }\r\n      this._storeState()\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Persist comment thread state.\r\n   */\r\n  _storeState() {\r\n    storage.set(this.itemId, JSON.stringify({\r\n      lastVisit: Date.now(),\r\n      commentCount: this.itemDescendantCount,\r\n      maxCommentId: this.maxCommentId\r\n    }))\r\n  },\r\n\r\n  /**\r\n   * The item this comment thread belongs to got updated.\r\n   */\r\n  itemUpdated(item) {\r\n    this.itemDescendantCount = item.descendants\r\n  },\r\n\r\n  /**\r\n   * A comment got loaded initially or added later.\r\n   */\r\n  commentAdded(comment) {\r\n    // Deleted comments don't count towards the comment count\r\n    if (comment.deleted) {\r\n      // Adjust the number of comments expected during the initial page load.\r\n      if (this.loading) {\r\n        this.expectedComments--\r\n        this.checkLoadCompletion()\r\n      }\r\n      return\r\n    }\r\n\r\n    CommentThreadStore.prototype.commentAdded.call(this, comment)\r\n\r\n    // Dead comments don't contribute to the comment count if showDead is off\r\n    if (comment.dead && !SettingsStore.showDead) {\r\n      this.expectedComments--\r\n    }\r\n    else {\r\n      this.commentCount++\r\n    }\r\n    // Add the number of kids the comment has to the expected total for the\r\n    // initial load.\r\n    if (this.loading && comment.kids) {\r\n      this.expectedComments += comment.kids.length\r\n    }\r\n    // Register the comment as new if it's new, unless it's dead and showDead is off\r\n    if (this.prevMaxCommentId > 0 &&\r\n        comment.id > this.prevMaxCommentId &&\r\n        (!comment.dead || SettingsStore.showDead)) {\r\n      this.newCommentCount++\r\n      this.isNew[comment.id] = true\r\n    }\r\n    // Keep track of the biggest comment id seen\r\n    if (comment.id > this.maxCommentId) {\r\n      this.maxCommentId = comment.id\r\n    }\r\n    // We don't want the story to be part of the comment parent hierarchy\r\n    if (comment.parent !== this.itemId) {\r\n      this.parents[comment.id] = comment.parent\r\n    }\r\n\r\n    this.numberOfCommentsChanged()\r\n    if (this.loading) {\r\n      this.checkLoadCompletion()\r\n    }\r\n  },\r\n\r\n  /**\r\n   * A comment which hasn't loaded yet is being delayed.\r\n   */\r\n  commentDelayed(commentId) {\r\n    // Don't wait for delayed comments\r\n    this.expectedComments--\r\n  },\r\n\r\n  /**\r\n   * A comment which wasn't previously deleted became deleted.\r\n   */\r\n  commentDeleted(comment) {\r\n    CommentThreadStore.prototype.commentDeleted.call(this, comment)\r\n    this.commentCount--\r\n    if (this.isNew[comment.id]) {\r\n      this.newCommentCount--\r\n      delete this.isNew[comment.id]\r\n    }\r\n    delete this.parents[comment.id]\r\n    // Trigger debounced callbacks\r\n    this.numberOfCommentsChanged()\r\n  },\r\n\r\n  /**\r\n   * A comment which wasn't previously dead became dead.\r\n   */\r\n  commentDied(comment) {\r\n    if (!SettingsStore.showDead) {\r\n      this.commentCount--\r\n      if (this.isNew[comment.id]) {\r\n        this.newCommentCount--\r\n        delete this.isNew[comment.id]\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Change the expected number of comments if an update was received during\r\n   * initial loding and trigger a re-check of loading completion.\r\n   */\r\n  adjustExpectedComments(change) {\r\n    this.expectedComments += change\r\n    this.checkLoadCompletion()\r\n  },\r\n\r\n  collapseThreadsWithoutNewComments() {\r\n    // Create an id lookup for comments which have a new comment as one of their\r\n    // descendants. New comments themselves are not added to the lookup.\r\n    var newCommentIds = Object.keys(this.isNew)\r\n    var hasNewComments = {}\r\n    for (var i = 0, l = newCommentIds.length; i < l; i++) {\r\n      var parent = this.parents[newCommentIds[i]]\r\n      while (parent) {\r\n        // Stop when we hit one we've seen before\r\n        if (hasNewComments[parent]) {\r\n          break\r\n        }\r\n        hasNewComments[parent] = true\r\n        parent = this.parents[parent]\r\n      }\r\n    }\r\n\r\n    // Walk the tree of comments one level at a time, only walking children to\r\n    // comments we know have new comment descendants, to find subtrees which\r\n    // don't have new comments.\r\n    // Other comments are marked for collapsing unless they are themselves a\r\n    // new comment (in which case all their replies must be new too).\r\n    var shouldCollapse = {}\r\n    var commentIds = this.children[this.itemId]\r\n    while (commentIds.length) {\r\n      var nextCommentIds = []\r\n      for (i = 0, l = commentIds.length; i < l; i++) {\r\n        var commentId = commentIds[i]\r\n        if (!hasNewComments[commentId]) {\r\n          if (!this.isNew[commentId]) {\r\n            shouldCollapse[commentId] = true\r\n          }\r\n        }\r\n        else {\r\n          var childCommentIds = this.children[commentId]\r\n          if (childCommentIds.length) {\r\n            nextCommentIds.push.apply(nextCommentIds, childCommentIds)\r\n          }\r\n        }\r\n      }\r\n      commentIds = nextCommentIds\r\n    }\r\n\r\n    this.isCollapsed = shouldCollapse\r\n    this.onCommentsChanged({type: 'collapse'})\r\n  },\r\n\r\n  /**\r\n   * Merk the thread as read.\r\n   */\r\n  markAsRead() {\r\n    this.lastVisit = Date.now()\r\n    this.newCommentCount = 0\r\n    this.prevMaxCommentId = this.maxCommentId\r\n    this.isNew = {}\r\n    this._storeState()\r\n  },\r\n\r\n  /**\r\n   * Persist comment thread state and perform any necessary internal cleanup.\r\n   */\r\n  dispose() {\r\n    // Cancel debounced callbacks in case any are pending\r\n    this.numberOfCommentsChanged.cancel()\r\n    this._storeState()\r\n  }\r\n})\r\n\r\nmodule.exports = StoryCommentThreadStore\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stores/StoryCommentThreadStore.js\n **/","var extend = require('../utils/extend')\r\n\r\nfunction CommentThreadStore(item, onCommentsChanged) {\r\n  this.itemId = item.id\r\n  this.onCommentsChanged = onCommentsChanged\r\n\r\n  /**\r\n   * Lookup from a comment id to its child comment ids.\r\n   * @type {Object.<id,Array.<Number>>}\r\n   */\r\n  this.children = {}\r\n  this.children[item.id] = []\r\n\r\n  /**\r\n   * Lookup for new comment ids. Will only contain true.\r\n   * @type {Object.<id,Boolean>}\r\n   */\r\n  this.isNew = {}\r\n\r\n  /**\r\n   * Lookup for collapsed state of comment ids. May contain true or false.\r\n   * @type {Object.<id,Boolean>}\r\n   */\r\n  this.isCollapsed = {}\r\n}\r\n\r\nextend(CommentThreadStore.prototype, {\r\n  /**\r\n   * Get counts of children and new comments under the given comment.\r\n   * @return .children {Number}\r\n   * @return .newComments {Number}\r\n   */\r\n  getChildCounts(comment) {\r\n    var childCount = 0\r\n    var newCommentCount = 0\r\n    var nodes = [comment.id]\r\n\r\n    while (nodes.length) {\r\n      var nextNodes = []\r\n      for (var i = 0, l = nodes.length; i < l; i++) {\r\n        var nodeChildren = this.children[nodes[i]]\r\n        if (nodeChildren.length) {\r\n          nextNodes.push.apply(nextNodes, nodeChildren)\r\n        }\r\n      }\r\n      for (i = 0, l = nextNodes.length; i < l; i++) {\r\n        if (this.isNew[nextNodes[i]]) {\r\n          newCommentCount++\r\n        }\r\n      }\r\n      childCount += nextNodes.length\r\n      nodes = nextNodes\r\n    }\r\n\r\n    return {\r\n      children: childCount,\r\n      newComments: newCommentCount\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Register a comment's appearance in the thread.\r\n   */\r\n  commentAdded(comment) {\r\n    if (comment.deleted) { return }\r\n\r\n    this.children[comment.id] = []\r\n    this.children[comment.parent].push(comment.id)\r\n  },\r\n\r\n  /**\r\n   * Register a comment's deletion from the thread.\r\n   */\r\n  commentDeleted(comment) {\r\n    // Comments which initially failed to load (null from Firebase API) can be\r\n    // deleted by the time the API catches up.\r\n    if (!comment) { return }\r\n\r\n    var siblings = this.children[comment.parent]\r\n    siblings.splice(siblings.indexOf(comment.id), 1)\r\n  },\r\n\r\n  toggleCollapse(commentId) {\r\n    this.isCollapsed[commentId] = !this.isCollapsed[commentId]\r\n    this.onCommentsChanged({type: 'collapse'})\r\n  }\r\n})\r\n\r\nmodule.exports = CommentThreadStore\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stores/CommentThreadStore.js\n **/","function extend(dest, src1, src2) {\r\n  var props = Object.keys(src1)\r\n  for (var i = 0, l = props.length; i < l; i++) {\r\n    dest[props[i]] = src1[props[i]]\r\n  }\r\n  if (src2) {\r\n    props = Object.keys(src2)\r\n    for (i = 0, l = props.length; i < l; i++) {\r\n      dest[props[i]] = src2[props[i]]\r\n    }\r\n  }\r\n  return dest\r\n}\r\n\r\nmodule.exports = extend\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/extend.js\n **/","var extend = require('../utils/extend')\r\nvar storage = require('../utils/storage')\r\n\r\nvar STORAGE_KEY = 'settings'\r\n\r\nvar SettingsStore = {\r\n  autoCollapse: true,\r\n  replyLinks: true,\r\n  showDead: false,\r\n  showDeleted: false,\r\n  titleFontSize: 18,\r\n  listSpacing: 16,\r\n  offlineMode: false,\r\n\r\n  load() {\r\n    var json = storage.get(STORAGE_KEY)\r\n    if (json) {\r\n      extend(this, JSON.parse(json))\r\n    }\r\n  },\r\n\r\n  save() {\r\n    storage.set(STORAGE_KEY, JSON.stringify({\r\n      autoCollapse: this.autoCollapse,\r\n      replyLinks: this.replyLinks,\r\n      showDead: this.showDead,\r\n      showDeleted: this.showDeleted,\r\n      titleFontSize: this.titleFontSize,\r\n      listSpacing: this.listSpacing,\r\n      offlineMode: this.offlineMode\r\n    }))\r\n  }\r\n}\r\n\r\nmodule.exports = SettingsStore\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stores/SettingsStore.js\n **/","module.exports = {\r\n  get(key, defaultValue) {\r\n    if (typeof window === 'undefined') {\r\n      return defaultValue\r\n    }\r\n    else {\r\n      var value = window.localStorage[key]\r\n      return (typeof value != 'undefined' ? value : defaultValue)\r\n    }\r\n  },\r\n  set(key, value) {\r\n    if (typeof window !== 'undefined') {\r\n      window.localStorage[key] = value\r\n    }\r\n  }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/storage.js\n **/","/**\r\n * Based on the implementation of _.debounce() from Underscore.js 1.7.0\r\n * http://underscorejs.org\r\n * (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n * Distributed under the MIT license.\r\n *\r\n * Returns a function, that, as long as it continues to be invoked, will not\r\n * be triggered. The function will be called after it stops being called for\r\n * N milliseconds. If `immediate` is passed, trigger the function on the\r\n * leading edge, instead of the trailing.\r\n *\r\n * The returned function has a .cancel() function which can be used to prevent\r\n * the debounced functiom being called.\r\n */\r\nfunction cancellableDebounce(func, wait, immediate) {\r\n  var timeout, args, context, timestamp, result\r\n\r\n  var later = function() {\r\n    var last = Date.now() - timestamp\r\n    if (last < wait && last > 0) {\r\n      timeout = setTimeout(later, wait - last)\r\n    }\r\n    else {\r\n      timeout = null\r\n      if (!immediate) {\r\n        result = func.apply(context, args)\r\n        if (!timeout) {\r\n          context = args = null\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  var debounced = function() {\r\n    context = this\r\n    args = arguments\r\n    timestamp = Date.now()\r\n    var callNow = immediate && !timeout\r\n    if (!timeout) {\r\n      timeout = setTimeout(later, wait)\r\n    }\r\n    if (callNow) {\r\n      result = func.apply(context, args)\r\n      context = args = null\r\n    }\r\n    return result\r\n  }\r\n\r\n  debounced.cancel = function() {\r\n    if (timeout) {\r\n      clearTimeout(timeout)\r\n    }\r\n  }\r\n\r\n  return debounced\r\n}\r\n\r\nmodule.exports = cancellableDebounce\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/cancellableDebounce.js\n **/","function pluralise(howMany, suffixes) {\r\n  return (suffixes || ',s').split(',')[(howMany === 1 ? 0 : 1)]\r\n}\r\n\r\nmodule.exports = pluralise\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/pluralise.js\n **/","var HNService = require('../services/HNService')\r\nvar HNServiceRest = require('../services/HNServiceRest')\r\n\r\nvar StoryStore = require('./StoryStore')\r\nvar UpdatesStore = require('./UpdatesStore')\r\nvar SettingsStore = require('./SettingsStore')\r\nvar commentParentLookup = {}\r\nvar titleCache = {}\r\n\r\nfunction fetchCommentParent(comment, cb, result) {\r\n  var commentId = comment.id\r\n  var parentId = comment.parent\r\n\r\n  while (commentParentLookup[parentId] || titleCache[parentId]) {\r\n    // We just saved ourselves an item fetch\r\n    result.itemCount++\r\n    result.cacheHits++\r\n\r\n    // The parent is a known non-comment\r\n    if (titleCache[parentId]) {\r\n      if (result.itemCount === 1) { result.parent = titleCache[parentId] }\r\n      result.op = titleCache[parentId]\r\n      cb(result)\r\n      return\r\n    }\r\n\r\n    // The parent is a known comment\r\n    if (commentParentLookup[parentId]) {\r\n      if (result.itemCount === 1) { result.parent = {id: parentId, type: 'comment'} }\r\n      // Set the parent comment's ids up for the next iteration\r\n      commentId = parentId\r\n      parentId = commentParentLookup[parentId]\r\n    }\r\n  }\r\n\r\n  // The parent of the current comment isn't known, so we'll have to fetch it\r\n  ItemStore.getItem(parentId, function(parent) {\r\n    result.itemCount++\r\n    // Add the current comment's parent to the lookup for next time\r\n    commentParentLookup[commentId] = parentId\r\n    if (parent.type === 'comment') {\r\n      commentParentLookup[parent.id] = parent.parent\r\n    }\r\n    processCommentParent(parent, cb, result)\r\n  }, result)\r\n}\r\n\r\nfunction processCommentParent(item, cb, result) {\r\n  if (result.itemCount === 1) {\r\n    result.parent = item\r\n  }\r\n  if (item.type !== 'comment') {\r\n    result.op = item\r\n    titleCache[item.id] = {\r\n      id: item.id,\r\n      type: item.type,\r\n      title: item.title\r\n    }\r\n    cb(result)\r\n  }\r\n  else {\r\n    fetchCommentParent(item, cb, result)\r\n  }\r\n}\r\n\r\nvar ItemStore = {\r\n  getItem(id, cb, result) {\r\n    var cachedItem = this.getCachedItem(id)\r\n    if (cachedItem) {\r\n      if (result) {\r\n        result.cacheHits++\r\n      }\r\n      setImmediate(cb, cachedItem)\r\n    }\r\n    else {\r\n      if (SettingsStore.offlineMode) {\r\n        HNServiceRest.fetchItem(id, cb)\r\n      }\r\n      else {\r\n        HNService.fetchItem(id, cb)\r\n      }\r\n    }\r\n  },\r\n\r\n  getCachedItem(id) {\r\n    return StoryStore.getItem(id) || UpdatesStore.getItem(id) || null\r\n  },\r\n\r\n  getCachedStory(id) {\r\n    return StoryStore.getItem(id) || UpdatesStore.getStory(id) || null\r\n  },\r\n\r\n  fetchCommentAncestors(comment, cb) {\r\n    var startTime = Date.now()\r\n    var result = {itemCount: 0, cacheHits: 0}\r\n    fetchCommentParent(comment, function() {\r\n      result.timeTaken = Date.now() - startTime\r\n      setImmediate(cb, result)\r\n    }, result)\r\n  }\r\n}\r\n\r\nmodule.exports = ItemStore\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stores/ItemStore.js\n **/","var {EventEmitter} = require('events')\r\n\r\nvar HNService = require('../services/HNService')\r\nvar HNServiceRest = require('../services/HNServiceRest')\r\nvar SettingsStore = require('./SettingsStore')\r\n\r\nvar extend = require('../utils/extend')\r\n\r\n/**\r\n * Firebase reference used to stream updates - only one StoryStore instance can\r\n * be active at a time.\r\n */\r\nvar firebaseRef = null\r\n\r\n// Cache objects shared among StoryStore instances, also accessible via static\r\n// functions on the StoryStore constructor.\r\n\r\n/**\r\n * Story ids by type, in rank order. Persisted to sessionStorage.\r\n * @type Object.<type, Array.<id>>\r\n */\r\nvar idCache = {}\r\n\r\n/**\r\n * Item cache. Persisted to sessionStorage.\r\n * @type Object.<id, item>\r\n */\r\nvar itemCache = {}\r\n\r\n/**\r\n * Story items in rank order for display, by type.\r\n * @type Object.<type, Array.<item>>\r\n */\r\nvar storyLists = {}\r\n\r\n/**\r\n * Populate the story list for the given story type from the cache.\r\n */\r\nfunction populateStoryList(type) {\r\n  var ids = idCache[type]\r\n  var storyList = storyLists[type]\r\n  for (var i = 0, l = ids.length; i < l; i++) {\r\n    storyList[i] = itemCache[ids[i]] || null\r\n  }\r\n}\r\n\r\nfunction parseJSON(json, defaultValue) {\r\n  return (json ? JSON.parse(json) : defaultValue)\r\n}\r\n\r\nclass StoryStore extends EventEmitter {\r\n  constructor(type) {\r\n    super()\r\n    this.type = type\r\n\r\n    // Ensure cache objects for this type are initialised\r\n    if (!(type in idCache)) {\r\n      idCache[type] = []\r\n    }\r\n    if (!(type in storyLists)) {\r\n      storyLists[type] = []\r\n      populateStoryList(type)\r\n    }\r\n\r\n    // Pre-bind event handlers per instance\r\n    this.onStorage = this.onStorage.bind(this)\r\n    this.onStoriesUpdated = this.onStoriesUpdated.bind(this)\r\n  }\r\n\r\n  getState() {\r\n    return {\r\n      ids: idCache[this.type],\r\n      stories: storyLists[this.type]\r\n    }\r\n  }\r\n\r\n  itemUpdated(item, index) {\r\n    storyLists[this.type][index] = item\r\n    itemCache[item.id] = item\r\n  }\r\n\r\n  /**\r\n   * Emit an item id event if a storage key corresponding to an item in the\r\n   * cache has changed.\r\n   */\r\n  onStorage(e) {\r\n    if (itemCache[e.key]) {\r\n      this.emit(e.key)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle story id snapshots from Firebase.\r\n   */\r\n  onStoriesUpdated(snapshot) {\r\n    if (SettingsStore.offlineMode) {\r\n      idCache[this.type] = snapshot\r\n    }\r\n    else {\r\n      idCache[this.type] = snapshot.val()\r\n    }\r\n    populateStoryList(this.type)\r\n    this.emit('update', this.getState())\r\n  }\r\n\r\n  start() {\r\n    if (typeof window === 'undefined') return\r\n    if (SettingsStore.offlineMode) {\r\n      HNServiceRest.storiesRef(this.type).then(function(res) {\r\n        return res.json()\r\n      }).then(function(snapshot) {\r\n        this.onStoriesUpdated(snapshot)\r\n      }.bind(this))\r\n    }\r\n    else {\r\n      firebaseRef = HNService.storiesRef(this.type)\r\n      firebaseRef.on('value', this.onStoriesUpdated)\r\n    }\r\n    window.addEventListener('storage', this.onStorage)\r\n  }\r\n\r\n  stop() {\r\n    if (firebaseRef !== null) {\r\n      if (!SettingsStore.offlineMode) {\r\n        firebaseRef.off()\r\n      }\r\n      firebaseRef = null\r\n    }\r\n    if (typeof window === 'undefined') return\r\n    window.removeEventListener('storage', this.onStorage)\r\n  }\r\n}\r\n\r\n// Static, cache-related functions\r\nextend(StoryStore, {\r\n  /**\r\n   * Get an item from the cache.\r\n   */\r\n  getItem(id) {\r\n    return itemCache[id] || null\r\n  },\r\n\r\n  /**\r\n   * Deserialise caches from sessionStorage.\r\n   */\r\n  loadSession() {\r\n    if (typeof window === 'undefined') return\r\n    if (SettingsStore.offlineMode) {\r\n      idCache = parseJSON(window.localStorage.idCache, {})\r\n      itemCache = parseJSON(window.localStorage.itemCache, {})\r\n    }\r\n    else {\r\n      idCache = parseJSON(window.sessionStorage.idCache, {})\r\n      itemCache = parseJSON(window.sessionStorage.itemCache, {})\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Serialise caches to sessionStorage as JSON.\r\n   */\r\n  saveSession() {\r\n    if (typeof window === 'undefined') return\r\n    if (SettingsStore.offlineMode) {\r\n      window.localStorage.setItem('idCache', JSON.stringify(idCache))\r\n      window.localStorage.setItem('itemCache', JSON.stringify(itemCache))\r\n    }\r\n    else {\r\n      window.sessionStorage.idCache = JSON.stringify(idCache)\r\n      window.sessionStorage.itemCache = JSON.stringify(itemCache)\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports = StoryStore\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stores/StoryStore.js\n **/","var EventEmitter = require('events').EventEmitter\r\n\r\nvar HNService = require('../services/HNService')\r\nvar HNServiceRest = require('../services/HNServiceRest')\r\nvar SettingsStore = require('./SettingsStore')\r\n\r\nvar {UPDATES_CACHE_SIZE} = require('../utils/constants')\r\nvar extend = require('../utils/extend')\r\n\r\n/**\r\n * Firebase reference used to stream updates.\r\n */\r\nvar updatesRef = null\r\n\r\n/**\r\n * Contains item id -> item cache objects. Persisted to sessionStorage.\r\n * @prop .comments {Object.<id,item>} comments cache.\r\n * @prop .stories {Object.<id,item>} story cache.\r\n */\r\nvar updatesCache = null\r\n\r\n/**\r\n * Lists of items in reverse chronological order for display.\r\n * @prop .comments {Array.<item>} comment updates.\r\n * @prop .stories {Array.<item>} story updates.\r\n */\r\nvar updates = {}\r\n\r\nfunction sortByTimeDesc(a, b) {\r\n  return b.time - a.time\r\n}\r\n\r\nfunction cacheObjToSortedArray(obj) {\r\n  var arr = Object.keys(obj).map(function(id) { return obj[id] })\r\n  arr.sort(sortByTimeDesc)\r\n  return arr\r\n}\r\n\r\n/**\r\n * Populate lists of updates for display from the cache.\r\n */\r\nfunction populateUpdates() {\r\n  updates.comments = processCacheObj(updatesCache.comments)\r\n  updates.stories = processCacheObj(updatesCache.stories)\r\n}\r\n\r\n/**\r\n * Create an array of items from a cache object, sorted in reverse chronological\r\n * order. Evict the oldest items from the cache if it's grown above\r\n * UPDATES_CACHE_SIZE.\r\n */\r\nfunction processCacheObj(cacheObj) {\r\n  var arr = cacheObjToSortedArray(cacheObj)\r\n  arr.splice(UPDATES_CACHE_SIZE, Math.max(0, arr.length - UPDATES_CACHE_SIZE))\r\n     .forEach(function(item) {\r\n       delete cacheObj[item.id]\r\n     })\r\n  return arr\r\n}\r\n\r\n/**\r\n * Lookup to filter out any items which appear in the updates feed which can't\r\n * be displayed by the Updates component.\r\n */\r\nvar updateItemTypes = {\r\n  comment: true,\r\n  job: true,\r\n  poll: true,\r\n  story: true\r\n}\r\n\r\n/**\r\n * Process incoming items from the update stream.\r\n */\r\nfunction handleUpdateItems(items) {\r\n  for (var i = 0, l = items.length; i < l; i++) {\r\n    var item = items[i]\r\n    // Silently ignore deleted items (because irony)\r\n    if (item.deleted) { continue }\r\n\r\n    if (typeof updateItemTypes[item.type] == 'undefined') {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.warn(\r\n          \"An item which can't be displayed by the Updates component was \" +\r\n          'received in the updates stream: ' + JSON.stringify(item)\r\n        )\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (item.type === 'comment') {\r\n      updatesCache.comments[item.id] = item\r\n    }\r\n    else {\r\n      updatesCache.stories[item.id] = item\r\n    }\r\n  }\r\n  populateUpdates()\r\n  UpdatesStore.emit('updates', updates)\r\n}\r\n\r\nvar UpdatesStore = extend(new EventEmitter(), {\r\n  loadSession() {\r\n    if (typeof window === 'undefined') return\r\n    var json = window.sessionStorage.updates\r\n    updatesCache = (json ? JSON.parse(json) : {comments: {}, stories: {}})\r\n    populateUpdates()\r\n  },\r\n\r\n  saveSession() {\r\n    if (typeof window === 'undefined') return\r\n    window.sessionStorage.updates = JSON.stringify(updatesCache)\r\n  },\r\n\r\n  start() {\r\n    if (updatesRef === null) {\r\n      if (SettingsStore.offlineMode) {\r\n        HNServiceRest.updatesRef().then(function(res) {\r\n          return res.json()\r\n        }).then(function(snapshot) {\r\n          HNServiceRest.fetchItems(snapshot, handleUpdateItems)\r\n        })\r\n      }\r\n      else {\r\n        updatesRef = HNService.updatesRef()\r\n        updatesRef.on('value', function(snapshot) {\r\n          HNService.fetchItems(snapshot.val(), handleUpdateItems)\r\n        })\r\n      }\r\n    }\r\n  },\r\n\r\n  stop() {\r\n    if (!SettingsStore.offlineMode) {\r\n      updatesRef.off()\r\n      updatesRef = null\r\n    }\r\n  },\r\n\r\n  getUpdates() {\r\n    return updates\r\n  },\r\n\r\n  getItem(id) {\r\n    return (updatesCache.comments[id] || updatesCache.stories[id] || null)\r\n  },\r\n\r\n  getComment(id) {\r\n    return (updatesCache.comments[id] || null)\r\n  },\r\n\r\n  getStory(id) {\r\n    return (updatesCache.stories[id] || null)\r\n  }\r\n})\r\nUpdatesStore.off = UpdatesStore.removeListener\r\n\r\nmodule.exports = UpdatesStore\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/stores/UpdatesStore.js\n **/","module.exports = {\r\n  ITEMS_PER_PAGE: 30,\r\n  SITE_TITLE: 'React HN',\r\n  UPDATES_CACHE_SIZE: 500\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/constants.js\n **/","var React = require('react')\r\n\r\nvar SettingsStore = require('./stores/SettingsStore')\r\n\r\nvar CommentMixin = require('./mixins/CommentMixin')\r\n\r\nvar cx = require('./utils/buildClassName')\r\n\r\n/**\r\n * Displays a standalone comment passed as a prop.\r\n */\r\nvar DisplayComment = React.createClass({\r\n  mixins: [CommentMixin],\r\n\r\n  propTypes: {\r\n    comment: React.PropTypes.object.isRequired\r\n  },\r\n\r\n  getInitialState() {\r\n    return {\r\n      op: {},\r\n      parent: {type: 'comment'}\r\n    }\r\n  },\r\n\r\n  componentWillMount() {\r\n    this.fetchAncestors(this.props.comment)\r\n  },\r\n\r\n  render() {\r\n    if (this.props.comment.deleted) { return null }\r\n    if (this.props.comment.dead && !SettingsStore.showDead) { return null }\r\n\r\n    var comment = this.props.comment\r\n    var className = cx('Comment Comment--level0', {\r\n      'Comment--dead': comment.dead\r\n    })\r\n\r\n    return <div className={className}>\r\n      <div className=\"Comment__content\">\r\n        {this.renderCommentMeta(comment, {\r\n          link: true,\r\n          parent: !!this.state.parent.id && !!this.state.op.id && comment.parent !== this.state.op.id,\r\n          op: !!this.state.op.id\r\n        })}\r\n        {this.renderCommentText(comment, {replyLink: false})}\r\n      </div>\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = DisplayComment\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/DisplayComment.js\n **/","var React = require('react')\r\nvar Link = require('react-router/lib/Link')\r\nvar TimeAgo = require('react-timeago').default\r\n\r\nvar ItemStore = require('../stores/ItemStore')\r\nvar SettingsStore = require('../stores/SettingsStore')\r\n\r\nvar Spinner = require('../Spinner')\r\n\r\nvar pluralise = require('../utils/pluralise')\r\n\r\nvar CommentMixin = {\r\n  fetchAncestors(comment) {\r\n    ItemStore.fetchCommentAncestors(comment, result => {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.info(\r\n          'fetchAncestors(' + comment.id + ') took ' +\r\n          result.timeTaken + ' ms for ' +\r\n          result.itemCount + ' item' + pluralise(result.itemCount) + ' with ' +\r\n          result.cacheHits + ' cache hit' + pluralise(result.cacheHits) + ' (' +\r\n          (result.cacheHits / result.itemCount * 100).toFixed(1) + '%)'\r\n        )\r\n      }\r\n      if (!this.isMounted()) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          console.info(\"...but the comment isn't mounted\")\r\n        }\r\n        // Too late - the comment or the user has moved elsewhere\r\n        return\r\n      }\r\n      this.setState({\r\n        parent: result.parent,\r\n        op: result.op\r\n      })\r\n    })\r\n  },\r\n\r\n  renderCommentLoading(comment) {\r\n    return <div className={'Comment Comment--loading Comment--level' + this.props.level}>\r\n      {(this.props.loadingSpinner || comment.delayed) && <Spinner size=\"20\"/>}\r\n      {comment.delayed && <div className=\"Comment__text\">\r\n        Unable to load comment &ndash; this usually indicates the author has configured a delay.\r\n        Trying again in 30 seconds.\r\n      </div>}\r\n    </div>\r\n  },\r\n\r\n  renderCommentDeleted(comment, options) {\r\n    return <div className={options.className}>\r\n      <div className=\"Comment__content\">\r\n        <div className=\"Comment__meta\">\r\n          [deleted] | <a href={'https://news.ycombinator.com/item?id=' + comment.id}>view on Hacker News</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  },\r\n\r\n  renderError(comment, options) {\r\n    return <div className={options.className}>\r\n      <div className=\"Comment__content\">\r\n        <div className=\"Comment__meta\">\r\n          [error] | comment is {JSON.stringify(comment)} | <a href={'https://news.ycombinator.com/item?id=' + options.id}>view on Hacker News</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  },\r\n\r\n  renderCollapseControl(collapsed) {\r\n    return <span className=\"Comment__collapse\" onClick={this.toggleCollapse} onKeyPress={this.toggleCollapse} tabIndex=\"0\">\r\n      [{collapsed ? '+' : ''}]\r\n    </span>\r\n  },\r\n\r\n  /**\r\n   * @param options.collapsible {Boolean} if true, assumes this.toggleCollspse()\r\n   * @param options.collapsed {Boolean}\r\n   * @param options.link {Boolean}\r\n   * @param options.parent {Boolean} if true, assumes this.state.parent\r\n   * @param options.op {Boolean} if true, assumes this.state.op\r\n   * @param options.childCounts {Object} with .children and .newComments\r\n   */\r\n  renderCommentMeta(comment, options) {\r\n    if (comment.dead && !SettingsStore.showDead) {\r\n      return <div className=\"Comment__meta\">\r\n        {options.collapsible && this.renderCollapseControl(options.collapsed)}\r\n        {options.collapsible && ' '}\r\n        [dead]\r\n        {options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren')}\r\n        {options.childCounts && options.childCounts.newComments > 0 && ', '}\r\n        {options.childCounts && options.childCounts.newComments > 0 && <em>{options.childCounts.newComments} new</em>}\r\n        {options.childCounts && ')'}\r\n      </div>\r\n    }\r\n\r\n    return <div className=\"Comment__meta\">\r\n      {options.collapsible && this.renderCollapseControl(options.collapsed)}\r\n      {options.collapsible && ' '}\r\n      <Link to={`/user/${comment.by}`} className=\"Comment__user\">{comment.by}</Link>{' '}\r\n      <TimeAgo date={comment.time * 1000}/>\r\n      {options.link && ' | '}\r\n      {options.link && <Link to={`/comment/${comment.id}`}>link</Link>}\r\n      {options.parent && ' | '}\r\n      {options.parent && <Link to={`/${this.state.parent.type}/${comment.parent}`}>parent</Link>}\r\n      {options.op && ' | on: '}\r\n      {options.op && <Link to={`/${this.state.op.type}/${this.state.op.id}`}>{this.state.op.title}</Link>}\r\n      {comment.dead && ' | [dead]'}\r\n      {options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren')}\r\n      {options.childCounts && options.childCounts.newComments > 0 && ', '}\r\n      {options.childCounts && options.childCounts.newComments > 0 && <em>{options.childCounts.newComments} new</em>}\r\n      {options.childCounts && ')'}\r\n    </div>\r\n  },\r\n\r\n  renderCommentText(comment, options) {\r\n    return <div className=\"Comment__text\">\r\n      {(!comment.dead || SettingsStore.showDead) ? <div dangerouslySetInnerHTML={{__html: comment.text}}/> : '[dead]'}\r\n      {SettingsStore.replyLinks && options.replyLink && !comment.dead && <p>\r\n        <a href={`https://news.ycombinator.com/reply?id=${comment.id}`}>reply</a>\r\n      </p>}\r\n    </div>\r\n  }\r\n}\r\n\r\nmodule.exports = CommentMixin\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mixins/CommentMixin.js\n **/","var React = require('react')\r\n\r\n// TODO Implement GIF-based fallback for IE9 and another non-animating browsers\r\n//      See https://github.com/tobiasahlin/SpinKit for how-to\r\nvar Spinner = React.createClass({\r\n  getDefaultProps() {\r\n    return {size: 6, spacing: 2}\r\n  },\r\n\r\n  render() {\r\n    var bounceSize = this.props.size + 'px'\r\n    var bounceStyle = {height: bounceSize, width: bounceSize, marginRight: this.props.spacing + 'px'}\r\n    return <div className=\"Spinner\" style={{width: ((Number(this.props.size) + Number(this.props.spacing)) * 3) + 'px'}}>\r\n      <div className=\"bounce1\" style={bounceStyle}/>\r\n      <div className=\"bounce2\" style={bounceStyle}/>\r\n      <div className=\"bounce3\" style={bounceStyle}/>\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = Spinner\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Spinner.js\n **/","/**\r\n * Creates a className string including some class names conditionally.\r\n * @param {string=} staticClassName class name(s) which should always be\r\n *   included.\r\n * @param {Object.<string, *>} conditionalClassNames an object mapping class\r\n *   names to a value which indicates if the class name should be included -\r\n *   class names will be included if their corresponding value is truthy.\r\n * @return {string}\r\n */\r\nfunction buildClassName(staticClassName, conditionalClassNames) {\r\n  var classNames = []\r\n  if (typeof conditionalClassNames == 'undefined') {\r\n    conditionalClassNames = staticClassName\r\n  }\r\n  else {\r\n    classNames.push(staticClassName)\r\n  }\r\n  var classNameKeys = Object.keys(conditionalClassNames)\r\n  for (var i = 0, l = classNameKeys.length; i < l; i++) {\r\n    if (conditionalClassNames[classNameKeys[i]]) {\r\n      classNames.push(classNameKeys[i])\r\n    }\r\n  }\r\n  return classNames.join(' ')\r\n}\r\n\r\nmodule.exports = buildClassName\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/buildClassName.js\n **/","var React = require('react')\r\nvar ReactFireMixin = require('reactfire')\r\n\r\nvar HNService = require('./services/HNService')\r\n\r\nvar Spinner = require('./Spinner')\r\n\r\nvar pluralise = require('./utils/pluralise')\r\n\r\nvar PollOption = React.createClass({\r\n  mixins: [ReactFireMixin],\r\n\r\n  getInitialState() {\r\n    return {pollopt: {}}\r\n  },\r\n\r\n  componentWillMount() {\r\n    this.bindAsObject(HNService.itemRef(this.props.id), 'pollopt')\r\n  },\r\n\r\n  render() {\r\n    var pollopt = this.state.pollopt\r\n    if (!pollopt.id) { return <div className=\"PollOption PollOption--loading\"><Spinner size=\"20\"/></div> }\r\n    return <div className=\"PollOption\">\r\n      <div className=\"PollOption__text\">\r\n        {pollopt.text}\r\n      </div>\r\n      <div className=\"PollOption__score\">\r\n        {pollopt.score} point{pluralise(pollopt.score)}\r\n      </div>\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = PollOption\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/PollOption.js\n **/","var React = require('react')\r\nvar Link = require('react-router/lib/Link')\r\nvar TimeAgo = require('react-timeago').default\r\n\r\nvar SettingsStore = require('../stores/SettingsStore')\r\nvar pluralise = require('../utils/pluralise')\r\nvar urlParse = require('url-parse')\r\n\r\nvar parseHost = function(url) {\r\n  var hostname = (urlParse(url, true)).hostname\r\n  var parts = hostname.split('.').slice(-3)\r\n  if (parts[0] === 'www') {\r\n    parts.shift()\r\n  }\r\n  return parts.join('.')\r\n}\r\n\r\n/**\r\n * Reusable logic for displaying an item.\r\n */\r\nvar ItemMixin = {\r\n  /**\r\n   * Render an item's metadata bar.\r\n   */\r\n  renderItemMeta(item, extraContent) {\r\n    var itemDate = new Date(item.time * 1000)\r\n\r\n    if (item.type === 'job') {\r\n      return <div className=\"Item__meta\">\r\n        <TimeAgo date={itemDate} className=\"Item__time\"/>\r\n      </div>\r\n    }\r\n\r\n    return <div className=\"Item__meta\">\r\n      <span className=\"Item__score\">\r\n        {item.score} point{pluralise(item.score)}\r\n      </span>{' '}\r\n      <span className=\"Item__by\">\r\n        by <Link to={`/user/${item.by}`}>{item.by}</Link>\r\n      </span>{' '}\r\n      <TimeAgo date={itemDate} className=\"Item__time\"/>\r\n      {' | '}\r\n      <Link to={`/${item.type}/${item.id}`}>\r\n        {item.descendants > 0 ? item.descendants + ' comment' + pluralise(item.descendants) : 'discuss'}\r\n      </Link>\r\n      {extraContent}\r\n    </div>\r\n  },\r\n\r\n  /**\r\n   * Render an item's title bar.\r\n   */\r\n  renderItemTitle(item) {\r\n    var hasURL = !!item.url\r\n    var title\r\n    if (item.dead) {\r\n      title = '[dead] ' + item.title\r\n    }\r\n    else {\r\n      title = (hasURL ? <a href={item.url}>{item.title}</a>\r\n                      : <Link to={`/${item.type}/${item.id}`}>{item.title}</Link>)\r\n    }\r\n    return <div className=\"Item__title\" style={{fontSize: SettingsStore.titleFontSize}}>\r\n      {title}\r\n      {hasURL && ' '}\r\n      {hasURL && <span className=\"Item__host\">({parseHost(item.url)})</span>}\r\n    </div>\r\n  }\r\n}\r\n\r\nmodule.exports = ItemMixin\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mixins/ItemMixin.js\n **/","var {SITE_TITLE} = require('./constants')\r\n\r\nfunction setTitle(title) {\r\n  if (typeof document === 'undefined') return\r\n  document.title = (title ? title + ' | ' + SITE_TITLE : SITE_TITLE)\r\n}\r\n\r\nmodule.exports = setTitle\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/setTitle.js\n **/","var React = require('react')\r\nvar Link = require('react-router/lib/Link')\r\n\r\nvar Settings = require('./Settings')\r\n\r\nvar StoryStore = require('./stores/StoryStore')\r\nvar UpdatesStore = require('./stores/UpdatesStore')\r\nvar SettingsStore = require('./stores/SettingsStore')\r\n\r\nvar App = React.createClass({\r\n  getInitialState() {\r\n    return {\r\n      showSettings: false,\r\n      showChildren: false,\r\n      prebootHTML: this.props.params.prebootHTML\r\n    }\r\n  },\r\n\r\n  componentWillMount() {\r\n    SettingsStore.load()\r\n    StoryStore.loadSession()\r\n    UpdatesStore.loadSession()\r\n    if (typeof window === 'undefined') return\r\n    window.addEventListener('beforeunload', this.handleBeforeUnload)\r\n  },\r\n\r\n  componentDidMount() {\r\n    // Empty the prebooted HTML and hydrate using live results from Firebase\r\n    this.setState({ prebootHTML: '', showChildren: true })\r\n  },\r\n\r\n  componentWillUnmount() {\r\n    if (typeof window === 'undefined') return\r\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\r\n  },\r\n\r\n  /**\r\n   * Give stores a chance to persist data to sessionStorage in case this is a\r\n   * refresh or an external link in the same tab.\r\n   */\r\n  handleBeforeUnload() {\r\n    StoryStore.saveSession()\r\n    UpdatesStore.saveSession()\r\n  },\r\n\r\n  toggleSettings(e) {\r\n    e.preventDefault()\r\n    this.setState({showSettings: !this.state.showSettings})\r\n  },\r\n\r\n  render() {\r\n    return <div className=\"App\" onClick={this.state.showSettings && this.toggleSettings}>\r\n      <div className=\"App__wrap\">\r\n        <div className=\"App__header\">\r\n          <Link to=\"/news\" className=\"App__homelinkicon\"><img src=\"img/logo.png\" width=\"16\" height=\"16\" alt=\"\" /></Link>{' '}\r\n          <Link to=\"/news\" activeClassName=\"active\" className=\"App__homelink\">React HN</Link>{' '}\r\n          <Link to=\"/newest\" activeClassName=\"active\">new</Link>{' | '}\r\n          <Link to=\"/newcomments\" activeClassName=\"active\">comments</Link> {' | '}\r\n          <Link to=\"/show\" activeClassName=\"active\">show</Link>{' | '}\r\n          <Link to=\"/ask\" activeClassName=\"active\">ask</Link>{' | '}\r\n          <Link to=\"/jobs\" activeClassName=\"active\">jobs</Link>\r\n          <a className=\"App__settings\" tabIndex=\"0\" onClick={this.toggleSettings} onKeyPress={this.toggleSettings}>\r\n            {this.state.showSettings ? 'hide settings' : 'settings'}\r\n          </a>\r\n          {this.state.showSettings && <Settings key=\"settings\"/>}\r\n        </div>\r\n        <div className=\"App__content\">\r\n          <div dangerouslySetInnerHTML={{ __html: this.state.prebootHTML }}/>\r\n          {this.state.showChildren ? this.props.children : ''}\r\n        </div>\r\n        <div className=\"App__footer\">\r\n          <a href=\"https://github.com/insin/react-hn\">insin/react-hn</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = App\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/App.js\n **/","var React = require('react')\r\n\r\nvar SettingsStore = require('./stores/SettingsStore')\r\n\r\nvar Settings = React.createClass({\r\n  componentDidMount() {\r\n    this.refs.container.focus()\r\n  },\r\n\r\n  onChange(e) {\r\n    var el = e.target\r\n    if (el.type === 'checkbox') {\r\n      SettingsStore[el.name] = el.checked\r\n    }\r\n    else if (el.type === 'number' && el.value) {\r\n      SettingsStore[el.name] = el.value\r\n    }\r\n    this.forceUpdate()\r\n    SettingsStore.save()\r\n  },\r\n\r\n  onClick(e) {\r\n    e.stopPropagation()\r\n  },\r\n\r\n  render() {\r\n    return <div ref=\"container\" className=\"Settings\" tabIndex=\"-1\" onClick={this.onClick}>\r\n      <form onChange={this.onChange}>\r\n        <div className=\"Settings__setting Settings__setting--checkbox\">\r\n          <label htmlFor=\"autoCollapse\">\r\n            <input type=\"checkbox\" name=\"autoCollapse\" id=\"autoCollapse\" checked={SettingsStore.autoCollapse}/> auto collapse\r\n          </label>\r\n          <p>Automatically collapse comment threads without new comments on page load.</p>\r\n        </div>\r\n        <div className=\"Settings__setting Settings__setting--checkbox\">\r\n          <label htmlFor=\"replyLinks\">\r\n            <input type=\"checkbox\" name=\"replyLinks\" id=\"replyLinks\" checked={SettingsStore.replyLinks}/> show reply links\r\n          </label>\r\n          <p>Show \"reply\" links to Hacker News</p>\r\n        </div>\r\n        <div className=\"Settings__setting Settings__setting--checkbox\">\r\n          <label htmlFor=\"offlineMode\">\r\n            <input type=\"checkbox\" name=\"offlineMode\" id=\"offlineMode\" checked={SettingsStore.offlineMode}/> Offline Mode\r\n          </label>\r\n          <p>Cache comments and content offline.</p>\r\n        </div>\r\n        <div className=\"Settings__setting Settings__setting--checkbox\">\r\n          <label htmlFor=\"showDead\">\r\n            <input type=\"checkbox\" name=\"showDead\" id=\"showDead\" checked={SettingsStore.showDead}/> show dead\r\n          </label>\r\n          <p>Show items flagged as dead.</p>\r\n        </div>\r\n        <div className=\"Settings__setting Settings__setting--checkbox\">\r\n          <label htmlFor=\"showDeleted\">\r\n            <input type=\"checkbox\" name=\"showDeleted\" id=\"showDeleted\" checked={SettingsStore.showDeleted}/> show deleted\r\n          </label>\r\n          <p>Show comments flagged as deleted in threads.</p>\r\n        </div>\r\n        <div className=\"Settings__setting\">\r\n          <table>\r\n            <tbody>\r\n              <tr>\r\n                <td><label htmlFor=\"titleFontSize\">title font size:</label></td>\r\n                <td><input type=\"number\" min=\"13.333\" step=\"1\" name=\"titleFontSize\" id=\"titleFontSize\" value={SettingsStore.titleFontSize}/></td>\r\n              </tr>\r\n              <tr>\r\n                <td><label htmlFor=\"listSpacing\">list spacing:</label></td>\r\n                <td><input type=\"number\" min=\"0\" name=\"listSpacing\" id=\"listSpacing\" value={SettingsStore.listSpacing}/></td>\r\n              </tr>\r\n            </tbody>\r\n          </table>\r\n        </div>\r\n      </form>\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = Settings\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Settings.js\n **/","var React = require('react')\r\n\r\nvar StoryStore = require('./stores/StoryStore')\r\n\r\nvar PageNumberMixin = require('./mixins/PageNumberMixin')\r\nvar Paginator = require('./Paginator')\r\nvar Spinner = require('./Spinner')\r\nvar StoryListItem = require('./StoryListItem')\r\nvar SettingsStore = require('./stores/SettingsStore')\r\n\r\nvar {ITEMS_PER_PAGE} = require('./utils/constants')\r\nvar pageCalc = require('./utils/pageCalc')\r\nvar setTitle = require('./utils/setTitle')\r\n\r\nvar Stories = React.createClass({\r\n  mixins: [PageNumberMixin],\r\n\r\n  propTypes: {\r\n    // The number of stories which may be paginated through\r\n    limit: React.PropTypes.number.isRequired,\r\n    // The route name being used\r\n    route: React.PropTypes.string.isRequired,\r\n    // The type of stories to be displayed\r\n    type: React.PropTypes.string.isRequired,\r\n\r\n    // Page title associated with the stories being displayed\r\n    title: React.PropTypes.string\r\n  },\r\n\r\n  getInitialState() {\r\n    return {\r\n      ids: [],\r\n      limit: this.props.limit,\r\n      stories: []\r\n    }\r\n  },\r\n\r\n  componentDidMount() {\r\n    setTitle(this.props.title)\r\n    this.store = new StoryStore(this.props.type)\r\n    this.store.addListener('update', this.handleUpdate)\r\n    this.store.start()\r\n    this.setState(this.store.getState())\r\n  },\r\n\r\n  componentWillUnmount() {\r\n    this.store.removeListener('update', this.handleUpdate)\r\n    this.store.stop()\r\n    this.store = null\r\n  },\r\n\r\n  handleUpdate(update) {\r\n    if (!this.isMounted()) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.warn(\r\n          `Skipping update as the ${this.props.type} Stories component is no longer mounted.`\r\n        )\r\n      }\r\n      return\r\n    }\r\n    update.limit = update.ids.length\r\n    this.setState(update)\r\n  },\r\n\r\n  render() {\r\n    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, this.state.limit)\r\n\r\n    // Display a list of placeholder items while we're waiting for the initial\r\n    // list of story ids to load from Firebase.\r\n    if (this.state.stories.length === 0 && this.state.ids.length === 0 && this.getPageNumber() > 0) {\r\n      var dummyItems = []\r\n      for (var i = page.startIndex; i < page.endIndex; i++) {\r\n        dummyItems.push(\r\n          <li key={i} className=\"ListItem ListItem--loading\" style={{marginBottom: SettingsStore.listSpacing}}>\r\n            <Spinner/>\r\n          </li>\r\n        )\r\n      }\r\n      return <div className=\"Items Items--loading\">\r\n        <ol className=\"Items__list\" start={page.startIndex + 1}>{dummyItems}</ol>\r\n        <Paginator route={this.props.route} page={page.pageNum} hasNext={page.hasNext}/>\r\n      </div>\r\n    }\r\n\r\n    return <div className=\"Items\">\r\n      <ol className=\"Items__list\" start={page.startIndex + 1}>\r\n        {this.renderItems(page.startIndex, page.endIndex)}\r\n      </ol>\r\n      <Paginator route={this.props.route} page={page.pageNum} hasNext={page.hasNext}/>\r\n    </div>\r\n  },\r\n\r\n  renderItems(startIndex, endIndex) {\r\n    var rendered = []\r\n    for (var i = startIndex; i < endIndex; i++) {\r\n      var item = this.state.stories[i]\r\n      var id = this.state.ids[i]\r\n      if (id) {\r\n        rendered.push(<StoryListItem key={id} id={id} index={i} cachedItem={item} store={this.store}/>)\r\n      }\r\n      else {\r\n        rendered.push(<StoryListItem cachedItem={item} store={this.store}/>)\r\n      }\r\n    }\r\n    return rendered\r\n  }\r\n})\r\n\r\nmodule.exports = Stories\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Stories.js\n **/","var PageNumberMixin = {\r\n  getPageNumber(page) {\r\n    if (typeof page == 'undefined') {\r\n      page = this.props.location.query.page\r\n    }\r\n    return (page && /^\\d+$/.test(page) ? Math.max(1, Number(page)) : 1)\r\n  }\r\n}\r\n\r\nmodule.exports = PageNumberMixin\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mixins/PageNumberMixin.js\n **/","var React = require('react')\r\nvar Link = require('react-router/lib/Link')\r\n\r\nvar Paginator = React.createClass({\r\n  _onClick(e) {\r\n    setTimeout(function() { window.scrollTo(0, 0) }, 0)\r\n  },\r\n\r\n  render() {\r\n    if (this.props.page === 1 && !this.props.hasNext) { return null }\r\n    return <div className=\"Paginator\">\r\n      {this.props.page > 1 && <span className=\"Paginator__prev\">\r\n        <Link to={{pathname: `/${this.props.route}`, query: {page: this.props.page - 1}}} onClick={this._onClick}>Prev</Link>\r\n      </span>}\r\n      {this.props.page > 1 && this.props.hasNext && ' | '}\r\n      {this.props.hasNext && <span className=\"Paginator__next\">\r\n        <Link to={{pathname: `/${this.props.route}`, query: {page: this.props.page + 1}}} onClick={this._onClick}>More</Link>\r\n      </span>}\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = Paginator\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Paginator.js\n **/","var React = require('react')\r\nvar ReactFireMixin = require('reactfire')\r\n\r\nvar StoryCommentThreadStore = require('./stores/StoryCommentThreadStore')\r\nvar HNService = require('./services/HNService')\r\nvar HNServiceRest = require('./services/HNServiceRest')\r\nvar SettingsStore = require('./stores/SettingsStore')\r\nvar StoryStore = require('./stores/StoryStore')\r\n\r\nvar ItemMixin = require('./mixins/ItemMixin')\r\nvar ListItemMixin = require('./mixins/ListItemMixin')\r\nvar Spinner = require('./Spinner')\r\n\r\n/**\r\n * Display story title and metadata as as a list item.\r\n * Cached story data may be given as a prop, but this component is also\r\n * responsible for listening to updates to the story and providing the latest\r\n * version for StoryStore's cache.\r\n */\r\nvar StoryListItem = React.createClass({\r\n  mixins: [ItemMixin, ListItemMixin, ReactFireMixin],\r\n\r\n  propTypes: {\r\n    // The StoryStore handling caching and updates to the stories being displayed\r\n    store: React.PropTypes.instanceOf(StoryStore).isRequired,\r\n\r\n    // The story's id in Hacker News\r\n    id: React.PropTypes.number,\r\n    // A version of the story from the cache, for initial display\r\n    cachedItem: React.PropTypes.object,\r\n    // The current index of the story in the list being displayed\r\n    index: React.PropTypes.number\r\n  },\r\n\r\n  getDefaultProps() {\r\n    return {\r\n      id: null,\r\n      cachedItem: null,\r\n      index: null\r\n    }\r\n  },\r\n\r\n  getInitialState() {\r\n    return {\r\n      item: this.props.cachedItem || {}\r\n    }\r\n  },\r\n\r\n  componentWillMount() {\r\n    if (this.props.id != null) {\r\n      this.initLiveItem(this.props)\r\n    }\r\n    else if (this.props.cachedItem != null) {\r\n      // Display the comment state of the cached item we were given while we're\r\n      // waiting for the live item to load.\r\n      this.threadState = StoryCommentThreadStore.loadState(this.state.item.id)\r\n    }\r\n  },\r\n\r\n  componentWillUnmount() {\r\n    if (this.props.id != null) {\r\n      this.props.store.removeListener(this.props.id, this.updateThreadState)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Catch the transition from not having an id prop to having one.\r\n   * Scenario: we were waiting for the initial list of story ids to load.\r\n   */\r\n  componentWillReceiveProps(nextProps) {\r\n    if (this.props.id == null && nextProps.id != null) {\r\n      this.initLiveItem(nextProps)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * If the live item has been loaded or updated, update the StoryStore cache\r\n   * with its current index and latest data.\r\n   */\r\n  componentWillUpdate(nextProps, nextState) {\r\n    if (this.state.item !== nextState.item) {\r\n      if (nextState.item != null) {\r\n        this.props.store.itemUpdated(nextState.item, this.props.index)\r\n      }\r\n      else {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          console.warn(`Item ${this.props.id} went from ${JSON.stringify(this.state.item)} to ${nextProps.item}`)\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Initialise listening to updates for the item with the given id and\r\n   * initialise its comment thread state.\r\n   */\r\n  initLiveItem(props) {\r\n    if (SettingsStore.offlineMode) {\r\n      HNServiceRest.itemRef(props.id).then(function(res) {\r\n        return res.json()\r\n      }).then(function(snapshot) {\r\n        this.replaceState({ item: snapshot })\r\n      }.bind(this))\r\n    }\r\n    else {\r\n      // If we were given a cached item to display initially, it will be replaced\r\n      this.bindAsObject(HNService.itemRef(props.id), 'item')\r\n    }\r\n\r\n    this.threadState = StoryCommentThreadStore.loadState(props.id)\r\n    this.props.store.addListener(props.id, this.updateThreadState)\r\n  },\r\n\r\n  /**\r\n   * Update thread state in response to a storage event indicating it has been\r\n   * modified.\r\n   */\r\n  updateThreadState() {\r\n    this.threadState = StoryCommentThreadStore.loadState(this.props.id)\r\n    this.forceUpdate()\r\n  },\r\n\r\n  render() {\r\n    // Display the loading spinner if we have nothing to show initially\r\n    if (!this.state.item || !this.state.item.id) {\r\n      return <li className=\"ListItem ListItem--loading\" style={{marginBottom: SettingsStore.listSpacing}}>\r\n        <Spinner/>\r\n      </li>\r\n    }\r\n\r\n    return this.renderListItem(this.state.item, this.threadState)\r\n  }\r\n})\r\n\r\nmodule.exports = StoryListItem\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/StoryListItem.js\n **/","var React = require('react')\r\nvar Link = require('react-router/lib/Link')\r\n\r\nvar SettingsStore = require('../stores/SettingsStore')\r\nvar cx = require('../utils/buildClassName')\r\n\r\n/**\r\n * Reusable logic for displaying an item in a list.\r\n * Must be used in conjunction with ItemMixin for its rendering methods.\r\n */\r\nvar ListItemMixin = {\r\n  getNewCommentCount(item, threadState) {\r\n    if (threadState.lastVisit === null) {\r\n      return 0\r\n    }\r\n    return item.descendants - threadState.commentCount\r\n  },\r\n\r\n  renderListItem(item, threadState) {\r\n    if (item.deleted) { return null }\r\n    var newCommentCount = this.getNewCommentCount(item, threadState)\r\n    return <li className={cx('ListItem', {'ListItem--dead': item.dead})} style={{marginBottom: SettingsStore.listSpacing}}>\r\n      {this.renderItemTitle(item)}\r\n      {this.renderItemMeta(item, (newCommentCount > 0 && <span className=\"ListItem__newcomments\">{' '}\r\n        (<Link to={`/${item.type}/${item.id}`}>\r\n          {newCommentCount} new\r\n        </Link>)\r\n      </span>))}\r\n    </li>\r\n  }\r\n}\r\n\r\nmodule.exports = ListItemMixin\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/mixins/ListItemMixin.js\n **/","function pageCalc(pageNum, pageSize, numItems) {\r\n  var startIndex = (pageNum - 1) * pageSize\r\n  var endIndex = Math.min(numItems, startIndex + pageSize)\r\n  var hasNext = endIndex < numItems - 1\r\n  return {pageNum, startIndex, endIndex, hasNext}\r\n}\r\n\r\nmodule.exports = pageCalc\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/pageCalc.js\n **/","var React = require('react')\r\n\r\nvar SettingsStore = require('./stores/SettingsStore')\r\nvar UpdatesStore = require('./stores/UpdatesStore')\r\n\r\nvar DisplayListItem = require('./DisplayListItem')\r\nvar DisplayComment = require('./DisplayComment')\r\nvar Paginator = require('./Paginator')\r\nvar Spinner = require('./Spinner')\r\n\r\nvar PageNumberMixin = require('./mixins/PageNumberMixin')\r\n\r\nvar {ITEMS_PER_PAGE} = require('./utils/constants')\r\nvar pageCalc = require('./utils/pageCalc')\r\nvar setTitle = require('./utils/setTitle')\r\n\r\nfunction filterDead(item) {\r\n  return !item.dead\r\n}\r\n\r\nfunction filterUpdates(updates) {\r\n  if (!SettingsStore.showDead) {\r\n    return {\r\n      comments: updates.comments.filter(filterDead),\r\n      stories: updates.stories.filter(filterDead)\r\n    }\r\n  }\r\n  return updates\r\n}\r\n\r\nvar Updates = React.createClass({\r\n  mixins: [PageNumberMixin],\r\n\r\n  getInitialState() {\r\n    return filterUpdates(UpdatesStore.getUpdates())\r\n  },\r\n\r\n  componentWillMount() {\r\n    this.setTitle(this.props.type)\r\n    UpdatesStore.start()\r\n    UpdatesStore.on('updates', this.handleUpdates)\r\n  },\r\n\r\n  componentWillUnmount() {\r\n    UpdatesStore.off('updates', this.handleUpdates)\r\n    UpdatesStore.stop()\r\n  },\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (this.props.type !== nextProps.type) {\r\n      this.setTitle(nextProps.type)\r\n    }\r\n  },\r\n\r\n  setTitle(type) {\r\n    setTitle('New ' + (type === 'comments' ? 'Comments' : 'Links'))\r\n  },\r\n\r\n  handleUpdates(updates) {\r\n    if (!this.isMounted()) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.warn('Skipping update of ' + this.props.type + ' as the Updates component is not mounted')\r\n      }\r\n      return\r\n    }\r\n    this.setState(filterUpdates(updates))\r\n  },\r\n\r\n  render() {\r\n    var items = (this.props.type === 'comments' ? this.state.comments : this.state.stories)\r\n    if (items.length === 0) {\r\n      return <div className=\"Updates Updates--loading\"><Spinner size=\"20\"/></div>\r\n    }\r\n\r\n    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, items.length)\r\n\r\n    if (this.props.type === 'comments') {\r\n      return <div className=\"Updates Comments\">\r\n        {items.slice(page.startIndex, page.endIndex).map(function(comment) {\r\n          return <DisplayComment key={comment.id} id={comment.id} comment={comment}/>\r\n        })}\r\n        <Paginator route=\"newcomments\" page={page.pageNum} hasNext={page.hasNext}/>\r\n      </div>\r\n    }\r\n    else {\r\n      return <div className=\"Updates Items\">\r\n        <ol className=\"Items__list\" start={page.startIndex + 1}>\r\n          {items.slice(page.startIndex, page.endIndex).map(function(item) {\r\n            return <DisplayListItem key={item.id} item={item}/>\r\n          })}\r\n        </ol>\r\n        <Paginator route=\"newest\" page={page.pageNum} hasNext={page.hasNext}/>\r\n      </div>\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports = Updates\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Updates.js\n **/","var React = require('react')\r\n\r\nvar StoryCommentThreadStore = require('./stores/StoryCommentThreadStore')\r\n\r\nvar ItemMixin = require('./mixins/ItemMixin')\r\nvar ListItemMixin = require('./mixins/ListItemMixin')\r\n\r\n/**\r\n * Display story title and metadata as a list item.\r\n * The story to display will be passed as a prop.\r\n */\r\nvar DisplayListItem = React.createClass({\r\n  mixins: [ItemMixin, ListItemMixin],\r\n\r\n  propTypes: {\r\n    item: React.PropTypes.object.isRequired\r\n  },\r\n\r\n  componentWillMount() {\r\n    this.threadState = StoryCommentThreadStore.loadState(this.props.item.id)\r\n  },\r\n\r\n  render() {\r\n    return this.renderListItem(this.props.item, this.threadState)\r\n  }\r\n})\r\n\r\nmodule.exports = DisplayListItem\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/DisplayListItem.js\n **/","var React = require('react')\r\nvar ReactFireMixin = require('reactfire')\r\n\r\nvar CommentThreadStore = require('./stores/CommentThreadStore')\r\nvar HNService = require('./services/HNService')\r\nvar HNServiceRest = require('./services/HNServiceRest')\r\nvar SettingsStore = require('./stores/SettingsStore')\r\n\r\nvar CommentMixin = require('./mixins/CommentMixin')\r\n\r\nvar cx = require('./utils/buildClassName')\r\n\r\n/**\r\n * A comment in a thread.\r\n */\r\nvar Comment = React.createClass({\r\n  mixins: [CommentMixin, ReactFireMixin],\r\n\r\n  propTypes: {\r\n    id: React.PropTypes.number.isRequired,\r\n    level: React.PropTypes.number.isRequired,\r\n    loadingSpinner: React.PropTypes.bool,\r\n    threadStore: React.PropTypes.instanceOf(CommentThreadStore).isRequired\r\n  },\r\n\r\n  getDefaultProps() {\r\n    return {\r\n      loadingSpinner: false\r\n    }\r\n  },\r\n\r\n  getInitialState() {\r\n    return {\r\n      comment: {}\r\n    }\r\n  },\r\n\r\n  componentWillMount() {\r\n    this.bindFirebaseRef()\r\n  },\r\n\r\n  componentWillUnmount() {\r\n    this.clearDelayTimeout()\r\n  },\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    // Huge, fast-growing threads like https://news.ycombinator.com/item?id=9784470\r\n    // seem to break the API - some comments are coming back from Firebase as null.\r\n    if (!this.state.comment) {\r\n      this.props.threadStore.adjustExpectedComments(-1)\r\n      return\r\n    }\r\n\r\n    // On !prevState.comment: a comment which was initially null - see\r\n    // above - may eventually load when the API catches up.\r\n    if (!prevState.comment || !prevState.comment.id) {\r\n      // Register a newly-loaded comment with the thread store\r\n      if (this.state.comment.id) {\r\n        // If the comment was delayed, cancel any pending timeout\r\n        if (prevState.comment && prevState.comment.delayed) {\r\n          this.clearDelayTimeout()\r\n        }\r\n        this.props.threadStore.commentAdded(this.state.comment)\r\n      }\r\n      if (prevState.comment && !prevState.comment.delayed && this.state.comment.delayed) {\r\n        this.props.threadStore.commentDelayed(this.props.id)\r\n      }\r\n    }\r\n    // The comment was already loaded, look for changes to it\r\n    else {\r\n      if (!prevState.comment.deleted && this.state.comment.deleted) {\r\n        this.props.threadStore.commentDeleted(this.state.comment)\r\n      }\r\n      if (!prevState.comment.dead && this.state.comment.dead) {\r\n        this.props.threadStore.commentDied(this.state.comment)\r\n      }\r\n      // If the comment has been updated and the initial set of comments is\r\n      // still loading, the number of expected comments might need to be\r\n      // adjusted.\r\n      else if (prevState.comment !== this.state.comment &&\r\n               this.props.threadStore.loading) {\r\n        var kids = (this.state.comment.kids ? this.state.comment.kids.length : 0)\r\n        var prevKids = (prevState.comment.kids ? prevState.comment.kids.length : 0)\r\n        this.props.threadStore.adjustExpectedComments(kids - prevKids)\r\n      }\r\n    }\r\n  },\r\n\r\n  bindFirebaseRef() {\r\n    if (SettingsStore.offlineMode) {\r\n      HNServiceRest.itemRef(this.props.id).then(function(res) {\r\n        return res.json()\r\n      }).then(function(snapshot) {\r\n        this.replaceState({ comment: snapshot })\r\n      }.bind(this))\r\n    }\r\n    else {\r\n      this.bindAsObject(HNService.itemRef(this.props.id), 'comment', this.handleFirebaseRefCancelled)\r\n    }\r\n\r\n    if (this.timeout) {\r\n      this.timeout = null\r\n    }\r\n  },\r\n\r\n  /**\r\n   * This is usually caused by a permissions error loading the comment due to\r\n   * its author using the delay setting (note: this is conjecture), which is\r\n   * measured in minutes - try again in 30 seconds.\r\n   */\r\n  handleFirebaseRefCancelled(e) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.error('Firebase ref for comment ' + this.props.id + ' was cancelled: ' + e.message)\r\n    }\r\n    this.unbind('comment')\r\n    this.timeout = setTimeout(this.bindFirebaseRef, 30000)\r\n    if (this.state.comment && !this.state.comment.delayed) {\r\n      this.state.comment.delayed = true\r\n      this.forceUpdate()\r\n    }\r\n  },\r\n\r\n  clearDelayTimeout() {\r\n    if (this.timeout) {\r\n      clearTimeout(this.timeout)\r\n      this.timeout = null\r\n    }\r\n  },\r\n\r\n  toggleCollapse(e) {\r\n    e.preventDefault()\r\n    this.props.threadStore.toggleCollapse(this.state.comment.id)\r\n  },\r\n\r\n  render() {\r\n    var comment = this.state.comment\r\n    var props = this.props\r\n    if (!comment) {\r\n      return this.renderError(comment, {\r\n        id: this.props.id,\r\n        className: 'Comment Comment--error Comment--level' + props.level\r\n      })\r\n    }\r\n    // Render a placeholder while we're waiting for the comment to load\r\n    if (!comment.id) { return this.renderCommentLoading(comment) }\r\n    // Don't show dead coments or their children, when configured\r\n    if (comment.dead && !SettingsStore.showDead) { return null }\r\n    // Render a link to HN for deleted comments if they're being displayed\r\n    if (comment.deleted) {\r\n      if (!SettingsStore.showDeleted) { return null }\r\n      return this.renderCommentDeleted(comment, {\r\n        className: 'Comment Comment--deleted Comment--level' + props.level\r\n      })\r\n    }\r\n\r\n    var isNew = props.threadStore.isNew[comment.id]\r\n    var collapsed = !!props.threadStore.isCollapsed[comment.id]\r\n    var childCounts = (collapsed && props.threadStore.getChildCounts(comment))\r\n    if (collapsed && isNew) { childCounts.newComments = 0 }\r\n    var className = cx('Comment Comment--level' + props.level, {\r\n      'Comment--collapsed': collapsed,\r\n      'Comment--dead': comment.dead,\r\n      'Comment--new': isNew\r\n    })\r\n\r\n    return <div className={className}>\r\n      <div className=\"Comment__content\">\r\n        {this.renderCommentMeta(comment, {\r\n          collapsible: true,\r\n          collapsed: collapsed,\r\n          link: true,\r\n          childCounts: childCounts\r\n        })}\r\n        {this.renderCommentText(comment, {replyLink: true})}\r\n      </div>\r\n      {comment.kids && <div className=\"Comment__kids\">\r\n        {comment.kids.map(function(id) {\r\n          return <Comment key={id} id={id}\r\n            level={props.level + 1}\r\n            loadingSpinner={props.loadingSpinner}\r\n            threadStore={props.threadStore}\r\n          />\r\n        })}\r\n      </div>}\r\n    </div>\r\n  }\r\n})\r\n\r\nmodule.exports = Comment\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Comment.js\n **/"],"sourceRoot":""}